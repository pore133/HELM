{"ast":null,"code":"import _toConsumableArray from \"C:\\\\Users\\\\JUN-D\\\\Desktop\\\\\\uD5EC\\uC2A4\\uCF00\\uC5B4\\\\11_6\\\\HELM\\\\front\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\n\n/**\r\n * DevExtreme (esm/core/utils/array.js)\r\n * Version: 23.1.6\r\n * Build date: Fri Oct 13 2023\r\n *\r\n * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { isDefined } from \"./type\";\nimport { orderEach } from \"./object\";\nimport config from \"../config\";\n\nfunction createOccurrenceMap(array) {\n  return array.reduce(function (map, value) {\n    var _map$get;\n\n    var count = (null !== (_map$get = map.get(value)) && void 0 !== _map$get ? _map$get : 0) + 1;\n    map.set(value, count);\n    return map;\n  }, new Map());\n}\n\nexport var wrapToArray = function wrapToArray(item) {\n  return Array.isArray(item) ? item : [item];\n};\nexport var getUniqueValues = function getUniqueValues(values) {\n  return _toConsumableArray(new Set(values));\n};\nexport var getIntersection = function getIntersection(firstArray, secondArray) {\n  var toRemoveMap = createOccurrenceMap(secondArray);\n  return firstArray.filter(function (value) {\n    var occurrencesCount = toRemoveMap.get(value);\n    occurrencesCount && toRemoveMap.set(value, occurrencesCount - 1);\n    return occurrencesCount;\n  });\n};\nexport var removeDuplicates = function removeDuplicates() {\n  var from = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];\n  var toRemove = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];\n  var toRemoveMap = createOccurrenceMap(toRemove);\n  return from.filter(function (value) {\n    var occurrencesCount = toRemoveMap.get(value);\n    occurrencesCount && toRemoveMap.set(value, occurrencesCount - 1);\n    return !occurrencesCount;\n  });\n};\nexport var normalizeIndexes = function normalizeIndexes(items, indexPropName, currentItem, needIndexCallback) {\n  var indexedItems = {};\n\n  var _config = config(),\n      useLegacyVisibleIndex = _config.useLegacyVisibleIndex;\n\n  var currentIndex = 0;\n\n  var shouldUpdateIndex = function shouldUpdateIndex(item) {\n    return !isDefined(item[indexPropName]) && (!needIndexCallback || needIndexCallback(item));\n  };\n\n  items.forEach(function (item) {\n    var index = item[indexPropName];\n\n    if (index >= 0) {\n      indexedItems[index] = indexedItems[index] || [];\n\n      if (item === currentItem) {\n        indexedItems[index].unshift(item);\n      } else {\n        indexedItems[index].push(item);\n      }\n    } else {\n      item[indexPropName] = void 0;\n    }\n  });\n\n  if (!useLegacyVisibleIndex) {\n    items.forEach(function (item) {\n      if (shouldUpdateIndex(item)) {\n        while (indexedItems[currentIndex]) {\n          currentIndex++;\n        }\n\n        indexedItems[currentIndex] = [item];\n        currentIndex++;\n      }\n    });\n  }\n\n  currentIndex = 0;\n  orderEach(indexedItems, function (index, items) {\n    items.forEach(function (item) {\n      if (index >= 0) {\n        item[indexPropName] = currentIndex++;\n      }\n    });\n  });\n\n  if (useLegacyVisibleIndex) {\n    items.forEach(function (item) {\n      if (shouldUpdateIndex(item)) {\n        item[indexPropName] = currentIndex++;\n      }\n    });\n  }\n};\nexport var groupBy = function groupBy(array, getGroupName) {\n  return array.reduce(function (groupedResult, item) {\n    var _groupedResult$groupN;\n\n    var groupName = getGroupName(item);\n    groupedResult[groupName] = null !== (_groupedResult$groupN = groupedResult[groupName]) && void 0 !== _groupedResult$groupN ? _groupedResult$groupN : [];\n    groupedResult[groupName].push(item);\n    return groupedResult;\n  }, {});\n};","map":null,"metadata":{},"sourceType":"module"}