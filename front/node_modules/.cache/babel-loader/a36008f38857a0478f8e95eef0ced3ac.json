{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tf = require(\"@tensorflow/tfjs\");\n\nvar tfjs_1 = require(\"@tensorflow/tfjs\");\n\nvar custom_posenet_1 = require(\"./custom-posenet\");\n\nvar seedrandom = require(\"seedrandom\");\n\nvar VALIDATION_FRACTION = 0.15; // tslint:disable-next-line:no-any\n// const isTensor = (c: any): c is tf.Tensor =>\n//     typeof c.dataId === 'object' && c.shape === 'object';\n\n/**\n * Converts an integer into its one-hot representation and returns\n * the data as a JS Array.\n */\n\nfunction flatOneHot(label, numClasses) {\n  var labelOneHot = new Array(numClasses).fill(0);\n  labelOneHot[label] = 1;\n  return labelOneHot;\n}\n/**\n * Shuffle an array of Float32Array or Samples using Fisher-Yates algorithm\n * Takes an optional seed value to make shuffling predictable\n */\n\n\nfunction fisherYates(array, seed) {\n  var _a;\n\n  var length = array.length; // need to clone array or we'd be editing original as we goo\n\n  var shuffled = array.slice();\n\n  for (var i = length - 1; i > 0; i -= 1) {\n    var randomIndex = void 0;\n\n    if (seed) {\n      randomIndex = Math.floor(seed() * (i + 1));\n    } else {\n      randomIndex = Math.floor(Math.random() * (i + 1));\n    }\n\n    _a = [shuffled[randomIndex], shuffled[i]], shuffled[i] = _a[0], shuffled[randomIndex] = _a[1];\n  }\n\n  return shuffled;\n}\n\nvar TeachablePoseNet =\n/** @class */\nfunction (_super) {\n  __extends(TeachablePoseNet, _super);\n\n  function TeachablePoseNet(model, posenetModel, metadata) {\n    var _this = _super.call(this, model, posenetModel, metadata) || this;\n\n    _this.model = model;\n    _this.posenetModel = posenetModel; // private __stopTrainingReject: (error: Error) => void;\n    // Number of total samples\n    // private totalSamples = 0;\n    // Array of all the examples collected\n\n    _this.examples = [];\n    return _this;\n  }\n\n  Object.defineProperty(TeachablePoseNet.prototype, \"isTrained\", {\n    /**\n     * has the teachable model been trained?\n     */\n    get: function get() {\n      return !!this.model && this.model.layers && this.model.layers.length > 2;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TeachablePoseNet.prototype, \"isPrepared\", {\n    /**\n     * has the dataset been prepared with all labels and samples processed?\n     */\n    get: function get() {\n      return !!this.trainDataset;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TeachablePoseNet.prototype, \"numClasses\", {\n    /**\n     * how many classes are in the dataset?\n     */\n    get: function get() {\n      return this._metadata.labels.length;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Add a sample of data under the provided className\n   * @param className the classification this example belongs to\n   * @param sample the image / tensor that belongs in this classification\n   */\n  // public async addExample(className: number, sample: HTMLCanvasElement | tf.Tensor) {\n\n  TeachablePoseNet.prototype.addExample = function (className, sample) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        // TODO: Do I need to normalize or flip image?\n        // const cap = isTensor(sample) ? sample : capture(sample);\n        // const example = this.posenet.predict(cap) as tf.Tensor;\n        // const embeddingsArray = await this.predictPosenet(sample);\n        // save samples of each class separately\n        this.examples[className].push(sample);\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n  /**\n   * Classify a pose output with your trained model. Return all results\n   * @param image the input image / Tensor to classify against your model\n   */\n\n\n  TeachablePoseNet.prototype.predict = function (poseOutput) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        if (!this.model) {\n          throw new Error('Model has not been trained yet, called train() first');\n        }\n\n        return [2\n        /*return*/\n        , _super.prototype.predict.call(this, poseOutput)];\n      });\n    });\n  };\n  /**\n   * Classify a pose output with your trained model. Return topK results\n   * @param image the input image / Tensor to classify against your model\n   * @param maxPredictions how many of the top results do you want? defautls to 3\n   */\n\n\n  TeachablePoseNet.prototype.predictTopK = function (poseOutput, maxPredictions) {\n    if (maxPredictions === void 0) {\n      maxPredictions = 3;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        if (!this.model) {\n          throw new Error('Model has not been trained yet, called train() first');\n        }\n\n        return [2\n        /*return*/\n        , _super.prototype.predictTopK.call(this, poseOutput, maxPredictions)];\n      });\n    });\n  };\n  /**\n   * process the current examples provided to calculate labels and format\n   * into proper tf.data.Dataset\n   */\n\n\n  TeachablePoseNet.prototype.prepare = function () {\n    for (var classes in this.examples) {\n      if (classes.length === 0) {\n        throw new Error('Add some examples before training');\n      }\n    }\n\n    var datasets = this.convertToTfDataset();\n    this.trainDataset = datasets.trainDataset;\n    this.validationDataset = datasets.validationDataset;\n  };\n  /**\n   * Process the examples by first shuffling randomly per class, then adding\n   * one-hot labels, then splitting into training/validation datsets, and finally\n   * sorting one last time\n   */\n\n\n  TeachablePoseNet.prototype.convertToTfDataset = function () {\n    // first shuffle each class individually\n    // TODO: we could basically replicate this by insterting randomly\n    for (var i = 0; i < this.examples.length; i++) {\n      this.examples[i] = fisherYates(this.examples[i], this.seed);\n    } // then break into validation and test datasets\n\n\n    var trainDataset = [];\n    var validationDataset = [];\n\n    var _loop_1 = function _loop_1(i) {\n      var y = flatOneHot(i, this_1.numClasses);\n      var classLength = this_1.examples[i].length;\n      var numValidation = Math.ceil(VALIDATION_FRACTION * classLength);\n      var numTrain = classLength - numValidation;\n      var classTrain = this_1.examples[i].slice(0, numTrain).map(function (dataArray) {\n        return {\n          data: dataArray,\n          label: y\n        };\n      });\n      var classValidation = this_1.examples[i].slice(numTrain).map(function (dataArray) {\n        return {\n          data: dataArray,\n          label: y\n        };\n      });\n      trainDataset = trainDataset.concat(classTrain);\n      validationDataset = validationDataset.concat(classValidation);\n    };\n\n    var this_1 = this; // for each class, add samples to train and validation dataset\n\n    for (var i = 0; i < this.examples.length; i++) {\n      _loop_1(i);\n    } // finally shuffle both train and validation datasets\n\n\n    trainDataset = fisherYates(trainDataset, this.seed);\n    validationDataset = fisherYates(validationDataset, this.seed);\n    var trainX = tf.data.array(trainDataset.map(function (sample) {\n      return sample.data;\n    }));\n    var validationX = tf.data.array(validationDataset.map(function (sample) {\n      return sample.data;\n    }));\n    var trainY = tf.data.array(trainDataset.map(function (sample) {\n      return sample.label;\n    }));\n    var validationY = tf.data.array(validationDataset.map(function (sample) {\n      return sample.label;\n    })); // return tf.data dataset objects\n\n    return {\n      trainDataset: tf.data.zip({\n        xs: trainX,\n        ys: trainY\n      }),\n      validationDataset: tf.data.zip({\n        xs: validationX,\n        ys: validationY\n      })\n    };\n  };\n  /**\n   * Saving `model`'s topology and weights as two files\n   * (`my-model-1.json` and `my-model-1.weights.bin`) as well as\n   * a `metadata.json` file containing metadata such as text labels to be\n   * downloaded from browser.\n   * @param handlerOrURL An instance of `IOHandler` or a URL-like,\n   * scheme-based string shortcut for `IOHandler`.\n   * @param config Options for saving the model.\n   * @returns A `Promise` of `SaveResult`, which summarizes the result of\n   * the saving, such as byte sizes of the saved artifacts for the model's\n   *   topology and weight values.\n   */\n\n\n  TeachablePoseNet.prototype.save = function (handlerOrURL, config) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.model.save(handlerOrURL, config)];\n      });\n    });\n  };\n  /**\n   * Train your data into a new model and join it with mobilenet\n   * @param params the parameters for the model / training\n   * @param callbacks provide callbacks to receive training events\n   */\n\n\n  TeachablePoseNet.prototype.train = function (params, callbacks) {\n    if (callbacks === void 0) {\n      callbacks = {};\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var originalOnTrainEnd, numLabels, inputSize, varianceScaling, optimizer, trainData, validationData;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            originalOnTrainEnd = callbacks.onTrainEnd || function () {};\n\n            callbacks.onTrainEnd = function (logs) {\n              if (_this.__stopTrainingResolve) {\n                _this.__stopTrainingResolve();\n\n                _this.__stopTrainingResolve = null;\n              }\n\n              originalOnTrainEnd(logs);\n            }; // Rest of train function\n\n\n            if (!this.isPrepared) {\n              this.prepare();\n            }\n\n            numLabels = this.getLabels().length;\n            tfjs_1.util.assert(numLabels === this.numClasses, function () {\n              return \"Can not train, has \" + numLabels + \" labels and \" + _this.numClasses + \" classes\";\n            });\n            inputSize = this.examples[0][1].length;\n\n            if (this.seed) {\n              varianceScaling = tf.initializers.varianceScaling({\n                seed: 3.14\n              });\n            } else {\n              varianceScaling = tf.initializers.varianceScaling({});\n            }\n\n            this.model = tf.sequential({\n              layers: [// Layer 1.\n              tf.layers.dense({\n                inputShape: [inputSize],\n                units: params.denseUnits,\n                activation: 'relu',\n                kernelInitializer: varianceScaling,\n                useBias: true\n              }), // Layer 2 dropout\n              tf.layers.dropout({\n                rate: 0.5\n              }), // Layer 3. The number of units of the last layer should correspond\n              // to the number of classes we want to predict.\n              tf.layers.dense({\n                units: this.numClasses,\n                kernelInitializer: varianceScaling,\n                useBias: false,\n                activation: 'softmax'\n              })]\n            });\n            optimizer = tf.train.rmsprop(params.learningRate);\n            this.model.compile({\n              optimizer: optimizer,\n              loss: 'categoricalCrossentropy',\n              metrics: ['accuracy']\n            });\n\n            if (!(params.batchSize > 0)) {\n              throw new Error(\"Batch size is 0 or NaN. Please choose a non-zero fraction\");\n            }\n\n            trainData = this.trainDataset.batch(params.batchSize);\n            validationData = this.validationDataset.batch(params.batchSize); // For debugging: check for shuffle or result from trainDataset\n\n            /*\n            await trainDataset.forEach((e: tf.Tensor[]) => {\n                console.log(e);\n                // @ts-ignore\n                let data = e.ys.dataSync() as Float32Array;\n                console.log(data);\n            });\n            */\n\n            return [4\n            /*yield*/\n            , this.model.fitDataset(trainData, {\n              epochs: params.epochs,\n              validationData: validationData,\n              callbacks: callbacks\n            })];\n\n          case 1:\n            // For debugging: check for shuffle or result from trainDataset\n\n            /*\n            await trainDataset.forEach((e: tf.Tensor[]) => {\n                console.log(e);\n                // @ts-ignore\n                let data = e.ys.dataSync() as Float32Array;\n                console.log(data);\n            });\n            */\n            _a.sent();\n\n            optimizer.dispose(); // cleanup\n\n            return [2\n            /*return*/\n            , this.model];\n        }\n      });\n    });\n  };\n  /*\n   * Setup the exampls array to hold samples per class\n   */\n\n\n  TeachablePoseNet.prototype.prepareDataset = function () {\n    for (var i = 0; i < this.numClasses; i++) {\n      this.examples[i] = [];\n    }\n  };\n\n  TeachablePoseNet.prototype.stopTraining = function () {\n    var _this = this;\n\n    var promise = new Promise(function (resolve, reject) {\n      _this.model.stopTraining = true;\n      _this.__stopTrainingResolve = resolve; // this.__stopTrainingReject = reject;\n    });\n    return promise;\n  };\n\n  TeachablePoseNet.prototype.dispose = function () {\n    this.model.dispose();\n\n    _super.prototype.dispose.call(this);\n  };\n\n  TeachablePoseNet.prototype.setLabel = function (index, label) {\n    this._metadata.labels[index] = label;\n  };\n\n  TeachablePoseNet.prototype.setLabels = function (labels) {\n    this._metadata.labels = labels;\n    this.prepareDataset();\n  };\n\n  TeachablePoseNet.prototype.getLabel = function (index) {\n    return this._metadata.labels[index];\n  };\n\n  TeachablePoseNet.prototype.getLabels = function () {\n    return this._metadata.labels;\n  };\n\n  TeachablePoseNet.prototype.setName = function (name) {\n    this._metadata.modelName = name;\n  };\n\n  TeachablePoseNet.prototype.getName = function () {\n    return this._metadata.modelName;\n  };\n  /*\n   * Calculate each class accuracy using the validation dataset\n   */\n\n\n  TeachablePoseNet.prototype.calculateAccuracyPerClass = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var validationXs, validationYs, batchSize, iterations, batchesX, batchesY, itX, itY, allX, allY, i, batchedXTensor, batchedXPredictionTensor, argMaxX, batchedYTensor, argMaxY, reference, predictions, i;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            validationXs = this.validationDataset.mapAsync(function (dataset) {\n              return __awaiter(_this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                  return [2\n                  /*return*/\n                  , dataset.xs];\n                });\n              });\n            });\n            validationYs = this.validationDataset.mapAsync(function (dataset) {\n              return __awaiter(_this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                  return [2\n                  /*return*/\n                  , dataset.ys];\n                });\n              });\n            });\n            batchSize = Math.min(validationYs.size, 32);\n            iterations = Math.ceil(validationYs.size / batchSize);\n            batchesX = validationXs.batch(batchSize);\n            batchesY = validationYs.batch(batchSize);\n            return [4\n            /*yield*/\n            , batchesX.iterator()];\n\n          case 1:\n            itX = _a.sent();\n            return [4\n            /*yield*/\n            , batchesY.iterator()];\n\n          case 2:\n            itY = _a.sent();\n            allX = [];\n            allY = [];\n            i = 0;\n            _a.label = 3;\n\n          case 3:\n            if (!(i < iterations)) return [3\n            /*break*/\n            , 7];\n            return [4\n            /*yield*/\n            , itX.next()];\n\n          case 4:\n            batchedXTensor = _a.sent();\n            batchedXPredictionTensor = this.model.predict(batchedXTensor.value);\n            argMaxX = batchedXPredictionTensor.argMax(1);\n            allX.push(argMaxX);\n            return [4\n            /*yield*/\n            , itY.next()];\n\n          case 5:\n            batchedYTensor = _a.sent();\n            argMaxY = batchedYTensor.value.argMax(1);\n            allY.push(argMaxY); // 3. dispose of all our tensors\n\n            batchedXTensor.value.dispose();\n            batchedXPredictionTensor.dispose();\n            batchedYTensor.value.dispose();\n            _a.label = 6;\n\n          case 6:\n            i++;\n            return [3\n            /*break*/\n            , 3];\n\n          case 7:\n            reference = tf.concat(allY);\n            predictions = tf.concat(allX); // only if we concatenated more than one tensor for preference and reference\n\n            if (iterations !== 1) {\n              for (i = 0; i < allX.length; i++) {\n                allX[i].dispose();\n                allY[i].dispose();\n              }\n            }\n\n            return [2\n            /*return*/\n            , {\n              reference: reference,\n              predictions: predictions\n            }];\n        }\n      });\n    });\n  };\n  /*\n   * optional seed for predictable shuffling of dataset\n   */\n\n\n  TeachablePoseNet.prototype.setSeed = function (seed) {\n    this.seed = seedrandom(seed);\n  };\n\n  return TeachablePoseNet;\n}(custom_posenet_1.CustomPoseNet);\n\nexports.TeachablePoseNet = TeachablePoseNet;\n\nfunction createTeachable(metadata) {\n  return __awaiter(this, void 0, void 0, function () {\n    var posenetModel;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , custom_posenet_1.loadPoseNet(metadata.modelSettings)];\n\n        case 1:\n          posenetModel = _a.sent();\n          return [2\n          /*return*/\n          , new TeachablePoseNet(tf.sequential(), posenetModel, metadata)];\n      }\n    });\n  });\n}\n\nexports.createTeachable = createTeachable;","map":null,"metadata":{},"sourceType":"script"}