{"ast":null,"code":"/**\r\n * DevExtreme (esm/core/utils/shadow_dom.js)\r\n * Version: 23.1.6\r\n * Build date: Fri Oct 13 2023\r\n *\r\n * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nvar DX_RULE_PREFIX = \"dx-\";\nvar ownerDocumentStyleSheet = null;\n\nfunction createConstructedStyleSheet(rootNode) {\n  try {\n    return new CSSStyleSheet();\n  } catch (err) {\n    var styleElement = rootNode.ownerDocument.createElement(\"style\");\n    rootNode.appendChild(styleElement);\n    return styleElement.sheet;\n  }\n}\n\nfunction processRules(targetStyleSheet, styleSheets, needApplyAllStyles) {\n  for (var i = 0; i < styleSheets.length; i++) {\n    var sheet = styleSheets[i];\n\n    try {\n      for (var j = 0; j < sheet.cssRules.length; j++) {\n        insertRule(targetStyleSheet, sheet.cssRules[j], needApplyAllStyles);\n      }\n    } catch (err) {}\n  }\n}\n\nfunction insertRule(targetStyleSheet, rule, needApplyAllStyles) {\n  var _rule$selectorText, _rule$cssRules, _rule$cssRules$, _rule$cssRules$$selec, _rule$name, _rule$style;\n\n  var isDxRule = needApplyAllStyles || (null === (_rule$selectorText = rule.selectorText) || void 0 === _rule$selectorText ? void 0 : _rule$selectorText.includes(DX_RULE_PREFIX)) || (null === (_rule$cssRules = rule.cssRules) || void 0 === _rule$cssRules ? void 0 : null === (_rule$cssRules$ = _rule$cssRules[0]) || void 0 === _rule$cssRules$ ? void 0 : null === (_rule$cssRules$$selec = _rule$cssRules$.selectorText) || void 0 === _rule$cssRules$$selec ? void 0 : _rule$cssRules$$selec.includes(DX_RULE_PREFIX)) || (null === (_rule$name = rule.name) || void 0 === _rule$name ? void 0 : _rule$name.startsWith(DX_RULE_PREFIX)) || \"DXIcons\" === (null === (_rule$style = rule.style) || void 0 === _rule$style ? void 0 : _rule$style.fontFamily);\n\n  if (isDxRule) {\n    targetStyleSheet.insertRule(rule.cssText, targetStyleSheet.cssRules.length);\n  }\n}\n\nexport function addShadowDomStyles($element) {\n  var _el$getRootNode;\n\n  var el = $element.get(0);\n  var root = null === (_el$getRootNode = el.getRootNode) || void 0 === _el$getRootNode ? void 0 : _el$getRootNode.call(el);\n\n  if (!(null !== root && void 0 !== root && root.host)) {\n    return;\n  }\n\n  if (!ownerDocumentStyleSheet) {\n    ownerDocumentStyleSheet = createConstructedStyleSheet(root);\n    processRules(ownerDocumentStyleSheet, el.ownerDocument.styleSheets, false);\n  }\n\n  var currentShadowDomStyleSheet = createConstructedStyleSheet(root);\n  processRules(currentShadowDomStyleSheet, root.styleSheets, true);\n  root.adoptedStyleSheets = [ownerDocumentStyleSheet, currentShadowDomStyleSheet];\n}\n\nfunction isPositionInElementRectangle(element, x, y) {\n  var rect = element.getBoundingClientRect();\n  return rect && x >= rect.left && x < rect.right && y >= rect.top && y < rect.bottom;\n}\n\nfunction createQueue() {\n  var shiftIndex = 0;\n  var items = [];\n  return {\n    push: function push(item) {\n      items.push(item);\n      return this;\n    },\n    shift: function shift() {\n      shiftIndex++;\n      return items[shiftIndex - 1];\n    },\n\n    get length() {\n      return items.length - shiftIndex;\n    },\n\n    get items() {\n      return items;\n    }\n\n  };\n}\n\nexport function getShadowElementsFromPoint(x, y, root) {\n  var elementQueue = createQueue().push(root);\n\n  while (elementQueue.length) {\n    var el = elementQueue.shift();\n\n    for (var i = 0; i < el.childNodes.length; i++) {\n      var childNode = el.childNodes[i];\n\n      if (childNode.nodeType === Node.ELEMENT_NODE && isPositionInElementRectangle(childNode, x, y) && \"none\" !== getComputedStyle(childNode).pointerEvents) {\n        elementQueue.push(childNode);\n      }\n    }\n  }\n\n  var result = elementQueue.items.reverse();\n  result.pop();\n  return result;\n}","map":null,"metadata":{},"sourceType":"module"}