{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nvar tf = require(\"@tensorflow/tfjs\");\n\nvar posenet = require(\"@tensorflow-models/posenet\");\n\nvar util_1 = require(\"@tensorflow-models/posenet/dist/util\");\n\nvar version_1 = require(\"./version\");\n\nvar posenet_1 = require(\"@tensorflow-models/posenet\");\n\nvar MAX_PREDICTIONS = 3;\n/**\n * Receives a Metadata object and fills in the optional fields such as timeStamp\n * @param data a Metadata object\n */\n\nvar fillMetadata = function fillMetadata(data) {\n  // util.assert(\n  // \ttypeof data.tfjsVersion === \"string\",\n  // \t() => `metadata.tfjsVersion is invalid`\n  // );\n  data.packageVersion = data.packageVersion || version_1.version;\n  data.packageName = '@teachablemachine/pose';\n  data.timeStamp = data.timeStamp || new Date().toISOString();\n  data.userMetadata = data.userMetadata || {};\n  data.modelName = data.modelName || \"untitled\";\n  data.labels = data.labels || [];\n  data.modelSettings = fillConfig(data.modelSettings);\n  return data;\n}; // tslint:disable-next-line:no-any\n\n\nvar isMetadata = function isMetadata(c) {\n  return !!c && Array.isArray(c.labels);\n};\n/**\n * process either a URL string or a Metadata object\n * @param metadata a url to load metadata or a Metadata object\n */\n\n\nvar processMetadata = function processMetadata(metadata) {\n  return __awaiter(void 0, void 0, void 0, function () {\n    var metadataJSON, metadataResponse;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          if (!(typeof metadata === \"string\")) return [3\n          /*break*/\n          , 3];\n          return [4\n          /*yield*/\n          , fetch(metadata)];\n\n        case 1:\n          metadataResponse = _a.sent();\n          return [4\n          /*yield*/\n          , metadataResponse.json()];\n\n        case 2:\n          metadataJSON = _a.sent();\n          return [3\n          /*break*/\n          , 4];\n\n        case 3:\n          if (isMetadata(metadata)) {\n            metadataJSON = metadata;\n          } else {\n            throw new Error(\"Invalid Metadata provided\");\n          }\n\n          _a.label = 4;\n\n        case 4:\n          return [2\n          /*return*/\n          , fillMetadata(metadataJSON)];\n      }\n    });\n  });\n};\n/**\n * process posenet configuration options\n * @param config a ModelSettings object\n */\n\n\nvar fillConfig = function fillConfig(config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  if (!config.posenet) {\n    config.posenet = {};\n  }\n\n  config.posenet.architecture = config.posenet.architecture || 'MobileNetV1';\n  config.posenet.outputStride = config.posenet.outputStride || 16;\n  config.posenet.inputResolution = config.posenet.inputResolution || 257;\n  config.posenet.multiplier = config.posenet.multiplier || 0.75;\n  return config;\n};\n/**\n * Computes the probabilities of the topK classes given logits by computing\n * softmax to get probabilities and then sorting the probabilities.\n * @param logits Tensor representing the logits from MobileNet.\n * @param topK The number of top predictions to show.\n */\n\n\nfunction getTopKClasses(labels, logits, topK) {\n  if (topK === void 0) {\n    topK = 3;\n  }\n\n  return __awaiter(this, void 0, void 0, function () {\n    var values;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , logits.data()];\n\n        case 1:\n          values = _a.sent();\n          return [2\n          /*return*/\n          , tf.tidy(function () {\n            topK = Math.min(topK, values.length);\n            var valuesAndIndices = [];\n\n            for (var i = 0; i < values.length; i++) {\n              valuesAndIndices.push({\n                value: values[i],\n                index: i\n              });\n            }\n\n            valuesAndIndices.sort(function (a, b) {\n              return b.value - a.value;\n            });\n            var topkValues = new Float32Array(topK);\n            var topkIndices = new Int32Array(topK);\n\n            for (var i = 0; i < topK; i++) {\n              topkValues[i] = valuesAndIndices[i].value;\n              topkIndices[i] = valuesAndIndices[i].index;\n            }\n\n            var topClassesAndProbs = [];\n\n            for (var i = 0; i < topkIndices.length; i++) {\n              topClassesAndProbs.push({\n                className: labels[topkIndices[i]],\n                probability: topkValues[i]\n              });\n            }\n\n            return topClassesAndProbs;\n          })];\n      }\n    });\n  });\n}\n\nexports.getTopKClasses = getTopKClasses;\n\nvar CustomPoseNet =\n/** @class */\nfunction () {\n  function CustomPoseNet(model, posenetModel, metadata) {\n    this.model = model;\n    this.posenetModel = posenetModel;\n    this._metadata = fillMetadata(metadata);\n  } // public model: tf.LayersModel;\n\n\n  CustomPoseNet.prototype.getMetadata = function () {\n    return this._metadata;\n  };\n  /**\n   * get the model labels\n   */\n\n\n  CustomPoseNet.prototype.getClassLabels = function () {\n    return this._metadata.labels;\n  };\n  /**\n   * get the total number of classes existing within model\n   */\n\n\n  CustomPoseNet.prototype.getTotalClasses = function () {\n    var output = this.model.output;\n    var totalClasses = output.shape[1];\n    return totalClasses;\n  };\n\n  CustomPoseNet.prototype.estimatePose = function (sample, flipHorizontal) {\n    if (flipHorizontal === void 0) {\n      flipHorizontal = false;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, heatmapScores, offsets, displacementFwd, displacementBwd, padding, posenetOutput, pose;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.estimatePoseOutputs(sample)];\n\n          case 1:\n            _a = _b.sent(), heatmapScores = _a.heatmapScores, offsets = _a.offsets, displacementFwd = _a.displacementFwd, displacementBwd = _a.displacementBwd, padding = _a.padding;\n            posenetOutput = this.poseOutputsToAray(heatmapScores, offsets, displacementFwd, displacementBwd);\n            return [4\n            /*yield*/\n            , this.poseOutputsToKeypoints(sample, heatmapScores, offsets, displacementFwd, displacementBwd, padding, flipHorizontal)];\n\n          case 2:\n            pose = _b.sent();\n            return [2\n            /*return*/\n            , {\n              pose: pose,\n              posenetOutput: posenetOutput\n            }];\n        }\n      });\n    });\n  }; // for multi pose\n  // taken from: https://github.com/tensorflow/tfjs-models/blob/master/posenet/src/posenet_model.ts\n\n\n  CustomPoseNet.prototype.estimatePoseOutputs = function (sample) {\n    return __awaiter(this, void 0, void 0, function () {\n      var inputResolution, _a, resized, padding, _b, heatmapScores, offsets, displacementFwd, displacementBwd;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            inputResolution = this.posenetModel.inputResolution;\n            _a = util_1.padAndResizeTo(sample, inputResolution), resized = _a.resized, padding = _a.padding;\n            return [4\n            /*yield*/\n            , this.posenetModel.baseModel.predict(resized)];\n\n          case 1:\n            _b = _c.sent(), heatmapScores = _b.heatmapScores, offsets = _b.offsets, displacementFwd = _b.displacementFwd, displacementBwd = _b.displacementBwd;\n            resized.dispose();\n            return [2\n            /*return*/\n            , {\n              heatmapScores: heatmapScores,\n              offsets: offsets,\n              displacementFwd: displacementFwd,\n              displacementBwd: displacementBwd,\n              padding: padding\n            }];\n        }\n      });\n    });\n  };\n\n  CustomPoseNet.prototype.poseOutputsToAray = function (heatmapScores, offsets, displacementFwd, displacementBwd) {\n    var axis = 2;\n    var concat = tf.concat([heatmapScores, offsets], axis);\n    var concatArray = concat.dataSync();\n    concat.dispose();\n    return concatArray;\n  };\n\n  CustomPoseNet.prototype.poseOutputsToKeypoints = function (input, heatmapScores, offsets, displacementFwd, displacementBwd, padding, flipHorizontal) {\n    if (flipHorizontal === void 0) {\n      flipHorizontal = false;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var config, _a, height, width, outputStride, inputResolution, _b, scoresBuffer, offsetsBuffer, displacementsFwdBuffer, displacementsBwdBuffer, poses, resultPoses;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            config = {\n              maxDetections: MAX_PREDICTIONS,\n              scoreThreshold: 0.5,\n              nmsRadius: 20\n            };\n            _a = util_1.getInputTensorDimensions(input), height = _a[0], width = _a[1];\n            outputStride = this.posenetModel.baseModel.outputStride;\n            inputResolution = this.posenetModel.inputResolution;\n            return [4\n            /*yield*/\n            , util_1.toTensorBuffers3D([heatmapScores, offsets, displacementFwd, displacementBwd])];\n\n          case 1:\n            _b = _c.sent(), scoresBuffer = _b[0], offsetsBuffer = _b[1], displacementsFwdBuffer = _b[2], displacementsBwdBuffer = _b[3];\n            return [4\n            /*yield*/\n            , posenet_1.decodeMultiplePoses(scoresBuffer, offsetsBuffer, displacementsFwdBuffer, displacementsBwdBuffer, outputStride, config.maxDetections, config.scoreThreshold, config.nmsRadius)];\n\n          case 2:\n            poses = _c.sent();\n            resultPoses = util_1.scaleAndFlipPoses(poses, [height, width], inputResolution, padding, flipHorizontal);\n            heatmapScores.dispose();\n            offsets.dispose();\n            displacementFwd.dispose();\n            displacementBwd.dispose();\n            return [2\n            /*return*/\n            , resultPoses[0]];\n        }\n      });\n    });\n  };\n  /**\n   * Given an image element, makes a prediction through posenet returning the\n   * probabilities for ALL classes.\n   * @param image the image to classify\n   * @param flipped whether to flip the image on X\n   */\n\n\n  CustomPoseNet.prototype.predict = function (poseOutput) {\n    return __awaiter(this, void 0, void 0, function () {\n      var embeddings, logits, values, classes, i;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            embeddings = tf.tensor([poseOutput]);\n            logits = this.model.predict(embeddings);\n            return [4\n            /*yield*/\n            , logits.data()];\n\n          case 1:\n            values = _a.sent();\n            classes = [];\n\n            for (i = 0; i < values.length; i++) {\n              classes.push({\n                className: this._metadata.labels[i],\n                probability: values[i]\n              });\n            }\n\n            embeddings.dispose();\n            logits.dispose();\n            return [2\n            /*return*/\n            , classes];\n        }\n      });\n    });\n  };\n  /**\n   * Given an image element, makes a prediction through posenet returning the\n   * probabilities of the top K classes.\n   * @param image the image to classify\n   * @param maxPredictions the maximum number of classification predictions\n   */\n\n\n  CustomPoseNet.prototype.predictTopK = function (poseOutput, maxPredictions) {\n    if (maxPredictions === void 0) {\n      maxPredictions = MAX_PREDICTIONS;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var embeddings, logits, topKClasses;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            embeddings = tf.tensor([poseOutput]);\n            logits = this.model.predict(embeddings);\n            return [4\n            /*yield*/\n            , getTopKClasses(this._metadata.labels, logits, maxPredictions)];\n\n          case 1:\n            topKClasses = _a.sent();\n            embeddings.dispose();\n            logits.dispose();\n            return [2\n            /*return*/\n            , topKClasses];\n        }\n      });\n    });\n  };\n\n  CustomPoseNet.prototype.dispose = function () {\n    this.posenetModel.dispose();\n  };\n\n  return CustomPoseNet;\n}();\n\nexports.CustomPoseNet = CustomPoseNet;\n\nfunction loadPoseNet(config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  return __awaiter(this, void 0, void 0, function () {\n    var posenetModel;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          config = fillConfig(config);\n          return [4\n          /*yield*/\n          , posenet.load({\n            architecture: config.posenet.architecture,\n            outputStride: config.posenet.outputStride,\n            inputResolution: config.posenet.inputResolution,\n            multiplier: config.posenet.multiplier\n          })];\n\n        case 1:\n          posenetModel = _a.sent();\n          return [2\n          /*return*/\n          , posenetModel];\n      }\n    });\n  });\n}\n\nexports.loadPoseNet = loadPoseNet;\n\nfunction load(checkpoint, metadata) {\n  return __awaiter(this, void 0, void 0, function () {\n    var customModel, metadataJSON, _a, posenetModel;\n\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , tf.loadLayersModel(checkpoint)];\n\n        case 1:\n          customModel = _b.sent();\n          if (!metadata) return [3\n          /*break*/\n          , 3];\n          return [4\n          /*yield*/\n          , processMetadata(metadata)];\n\n        case 2:\n          _a = _b.sent();\n          return [3\n          /*break*/\n          , 4];\n\n        case 3:\n          _a = null;\n          _b.label = 4;\n\n        case 4:\n          metadataJSON = _a;\n          return [4\n          /*yield*/\n          , loadPoseNet(metadataJSON.modelSettings)];\n\n        case 5:\n          posenetModel = _b.sent();\n          return [2\n          /*return*/\n          , new CustomPoseNet(customModel, posenetModel, metadataJSON)];\n      }\n    });\n  });\n}\n\nexports.load = load;\n\nfunction loadFromFiles(json, weights, metadata) {\n  return __awaiter(this, void 0, void 0, function () {\n    var customModel, metadataFile, metadataJSON, _a, posenetModel;\n\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , tf.loadLayersModel(tf.io.browserFiles([json, weights]))];\n\n        case 1:\n          customModel = _b.sent();\n          return [4\n          /*yield*/\n          , new Response(metadata).json()];\n\n        case 2:\n          metadataFile = _b.sent();\n          if (!metadata) return [3\n          /*break*/\n          , 4];\n          return [4\n          /*yield*/\n          , processMetadata(metadataFile)];\n\n        case 3:\n          _a = _b.sent();\n          return [3\n          /*break*/\n          , 5];\n\n        case 4:\n          _a = null;\n          _b.label = 5;\n\n        case 5:\n          metadataJSON = _a;\n          return [4\n          /*yield*/\n          , loadPoseNet(metadataJSON.modelSettings)];\n\n        case 6:\n          posenetModel = _b.sent();\n          return [2\n          /*return*/\n          , new CustomPoseNet(customModel, posenetModel, metadataJSON)];\n      }\n    });\n  });\n}\n\nexports.loadFromFiles = loadFromFiles;","map":null,"metadata":{},"sourceType":"script"}