{"ast":null,"code":"import _toConsumableArray from \"C:\\\\Users\\\\JUN-D\\\\Desktop\\\\\\uD5EC\\uC2A4\\uCF00\\uC5B4\\\\11_2\\\\HELF-master\\\\front\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\n\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as util from '../util';\nvar NEW_AXIS = -2;\nvar SHRINK_AXIS = -1;\nexport function assertParamsValid(input, begin, size) {\n  var inputRank = input.shape.length;\n  util.assert(inputRank === begin.length, function () {\n    return \"Error in slice\".concat(inputRank, \"D: Length of begin \").concat(begin, \" must \") + \"match the rank of the array (\".concat(inputRank, \").\");\n  });\n  util.assert(inputRank === size.length, function () {\n    return \"Error in slice\".concat(inputRank, \"D: Length of size \").concat(size, \" must \") + \"match the rank of the array (\".concat(inputRank, \").\");\n  });\n\n  var _loop = function _loop(i) {\n    util.assert(begin[i] + size[i] <= input.shape[i], function () {\n      return \"Error in slice\".concat(inputRank, \"D: begin[\").concat(i, \"] + size[\").concat(i, \"] \") + \"(\".concat(begin[i] + size[i], \") would overflow input.shape[\").concat(i, \"] (\").concat(input.shape[i], \")\");\n    });\n  };\n\n  for (var i = 0; i < inputRank; ++i) {\n    _loop(i);\n  }\n}\n/** Converts a binary mask to an array of axes. Used in stridedSlice(). */\n\nexport function maskToAxes(mask) {\n  var axes = [];\n  var axis = 0;\n\n  while (mask > 0) {\n    if (mask & 1) {\n      axes.push(axis);\n    }\n\n    mask /= 2;\n    axis++;\n  }\n\n  return axes;\n}\n/** Computes the output shape given the strided slice params. */\n\nexport function computeOutShape(begin, end, strides) {\n  var size = [];\n\n  for (var axis = 0; axis < begin.length; axis++) {\n    size[axis] = Math.ceil((end[axis] - begin[axis]) / strides[axis]);\n  }\n\n  return size;\n} // Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current stride value. Otherwise, insert.\n\nexport function stridesWithElidedDims(strides, ellipsisInsertionIndex, numElidedAxes, inputShape) {\n  var newStrides = _toConsumableArray(strides);\n\n  for (var i = newStrides.length; i < inputShape.length; i++) {\n    newStrides.push(1);\n  }\n\n  for (var _i = 0; _i < numElidedAxes; _i++) {\n    if (_i === 0) {\n      newStrides[ellipsisInsertionIndex] = 1;\n    } else {\n      newStrides.splice(ellipsisInsertionIndex, 0\n      /* num elements to delete */\n      , 1\n      /* element to add */\n      );\n      newStrides.pop();\n    }\n  }\n\n  return newStrides;\n}\n\nfunction unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, normalizedAxis) {\n  if (normalizedAxis <= ellipsisInsertionIndex) {\n    return normalizedAxis;\n  }\n\n  return normalizedAxis - (numElidedAxes - 1);\n}\n\nfunction getElidedAxes(numElidedAxes, ellipsisInsertionIndex) {\n  var elidedAxes = [];\n\n  for (var i = 0; i < numElidedAxes; i++) {\n    elidedAxes.push(ellipsisInsertionIndex + i);\n  }\n\n  return elidedAxes;\n} // Normalize the start, end and strides.\n\n\nexport function getNormalizedAxes(inputShape, ellipsisAxes, numInterpolatedAxes, begin, end, strides, beginMask, endMask, ellipsisMask) {\n  var inputRank = inputShape.length;\n  var normalizedBegin = new Array(inputRank),\n      normalizedEnd = new Array(inputRank),\n      normalizedStrides = new Array(inputRank);\n\n  if (ellipsisAxes.length && numInterpolatedAxes > 0) {\n    var fullIndex = ellipsisAxes[0]; // The ellipsis applies to the masked index as well as any dimensions\n    // that are interpolated.\n\n    var numElidedAxes = numInterpolatedAxes + 1;\n    normalizedBegin = startIndicesWithElidedDims(beginMask, fullIndex, numElidedAxes, begin, inputShape);\n    normalizedEnd = stopIndicesWithElidedDims(endMask, fullIndex, numElidedAxes, end, inputShape);\n    normalizedStrides = stridesWithElidedDims(strides, fullIndex, numElidedAxes, inputShape);\n  } else {\n    for (var axis = 0; axis < inputRank; axis++) {\n      normalizedBegin[axis] = startForAxis(beginMask, begin, strides, inputShape, axis, ellipsisMask);\n      normalizedEnd[axis] = stopForAxis(endMask, end, strides, inputShape, axis, ellipsisMask);\n      normalizedStrides[axis] = stridesForAxis(strides, axis, ellipsisMask);\n    }\n  }\n\n  return {\n    begin: normalizedBegin,\n    end: normalizedEnd,\n    strides: normalizedStrides\n  };\n} // Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current start value. Otherwise, insert.\n\nexport function startIndicesWithElidedDims(beginMask, ellipsisInsertionIndex, numElidedAxes, originalBegin, inputShape) {\n  var newIndices = _toConsumableArray(inputShape);\n\n  var elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);\n\n  for (var axis = 0; axis < newIndices.length; axis++) {\n    if (elidedAxes.indexOf(axis) > -1) {\n      newIndices[axis] = 0;\n    } else {\n      var originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);\n      var originalValue = originalBegin[originalAxis];\n\n      if (beginMask & 1 << originalAxis) {\n        originalValue = 0;\n      }\n\n      newIndices[axis] = originalValue;\n    }\n  }\n\n  return newIndices;\n} // Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current stop value. Otherwise, insert.\n\nexport function stopIndicesWithElidedDims(endMask, ellipsisInsertionIndex, numElidedAxes, originalEnd, inputShape) {\n  var newIndices = _toConsumableArray(inputShape);\n\n  var elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);\n\n  for (var axis = 0; axis < newIndices.length; axis++) {\n    if (elidedAxes.indexOf(axis) > -1) {\n      newIndices[axis] = Number.MAX_SAFE_INTEGER;\n    } else {\n      var originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);\n      var originalValue = originalEnd[originalAxis];\n\n      if (endMask & 1 << originalAxis) {\n        originalValue = Number.MAX_SAFE_INTEGER;\n      }\n\n      newIndices[axis] = originalValue;\n    }\n  }\n\n  for (var i = 0; i < newIndices.length; i++) {\n    // Handle negative indices\n    var axisSize = inputShape[i];\n\n    if (newIndices[i] < 0) {\n      newIndices[i] += axisSize;\n    }\n\n    newIndices[i] = util.clamp(0, newIndices[i], inputShape[i]);\n  }\n\n  return newIndices;\n}\nexport function stridesForAxis(strides, axis, ellipsisMask) {\n  var stride = strides[axis];\n\n  if (ellipsisMask & 1 << axis || stride == null) {\n    stride = 1;\n  }\n\n  return stride;\n}\nexport function startForAxis(beginMask, startIndices, strides, inputShape, axis, ellipsisMask) {\n  // Begin with the specified index\n  var start = startIndices[axis];\n  var stride = strides[axis] || 1; // Check the axis bit from right of masked axes, or the begin index is not set\n  // for the axis.\n\n  if (beginMask & 1 << axis || ellipsisMask & 1 << axis || start == null) {\n    if (stride > 0) {\n      // Forward iteration - use the first element. These values will get\n      // clamped below (Note: We could have set them to 0 and axis_size-1, but\n      // use lowest() and max() to maintain symmetry with StopForAxis())\n      start = Number.MIN_SAFE_INTEGER;\n    } else {\n      // Backward iteration - use the last element.\n      start = Number.MAX_SAFE_INTEGER;\n    }\n  } // Handle negative indices\n\n\n  var axisSize = inputShape[axis];\n\n  if (start < 0) {\n    start += axisSize;\n  } // Clamping\n\n\n  start = util.clamp(0, start, axisSize - 1);\n  return start;\n}\nexport function stopForAxis(endMask, stopIndices, strides, inputShape, axis, ellipsisMask) {\n  // Begin with the specified index\n  var stop = stopIndices[axis];\n  var stride = strides[axis] || 1; // Check the axis bit from right of masked axes, or if the stop index is not\n  // set for this axis.\n\n  if (endMask & 1 << axis || ellipsisMask & 1 << axis || stop == null) {\n    if (stride > 0) {\n      // Forward iteration - use the last element. These values will get\n      // clamped below\n      stop = Number.MAX_SAFE_INTEGER;\n    } else {\n      // Backward iteration - use the first element.\n      stop = Number.MIN_SAFE_INTEGER;\n    }\n  } // Handle negative indices\n\n\n  var axisSize = inputShape[axis];\n\n  if (stop < 0) {\n    stop += axisSize;\n  } // Clamping\n  // Because the end index points one past the last element, we need slightly\n  // different clamping ranges depending on the direction.\n\n\n  if (stride > 0) {\n    // Forward iteration\n    stop = util.clamp(0, stop, axisSize);\n  } else {\n    // Backward iteration\n    stop = util.clamp(-1, stop, axisSize - 1);\n  }\n\n  return stop;\n}\n/**\n * Returns true if the slice occupies a continous set of elements in the\n * 'flat' space.\n */\n\nexport function isSliceContinous(shape, begin, size) {\n  // Index of the first axis that has size > 1.\n  var firstNonOneAxis = size.length;\n\n  for (var i = 0; i < size.length; i++) {\n    if (size[i] > 1) {\n      firstNonOneAxis = i;\n      break;\n    }\n  }\n\n  for (var _i2 = firstNonOneAxis + 1; _i2 < size.length; _i2++) {\n    if (begin[_i2] > 0 || size[_i2] !== shape[_i2]) {\n      return false;\n    }\n  }\n\n  return true;\n}\nexport function computeFlatOffset(begin, strides) {\n  var flatOffset = begin.length > 0 ? begin[begin.length - 1] : 1;\n\n  for (var i = 0; i < begin.length - 1; i++) {\n    flatOffset += begin[i] * strides[i];\n  }\n\n  return flatOffset;\n}\nexport function parseSliceParams(x, begin, size) {\n  // The following logic allows for more ergonomic calls.\n  var begin_;\n  var xRank = x.shape.length;\n\n  if (typeof begin === 'number') {\n    begin_ = [begin].concat(_toConsumableArray(new Array(xRank - 1).fill(0)));\n  } else if (begin.length < xRank) {\n    begin_ = begin.concat(new Array(xRank - begin.length).fill(0));\n  } else {\n    begin_ = begin.slice();\n  }\n\n  begin_.forEach(function (d) {\n    util.assert(d !== -1, function () {\n      return 'slice() does not support negative begin indexing.';\n    });\n  });\n  var size_;\n\n  if (size == null) {\n    size_ = new Array(xRank).fill(-1);\n  } else if (typeof size === 'number') {\n    size_ = [size].concat(_toConsumableArray(new Array(xRank - 1).fill(-1)));\n  } else if (size.length < xRank) {\n    size_ = size.concat(new Array(xRank - size.length).fill(-1));\n  } else {\n    size_ = size;\n  }\n\n  size_ = size_.map(function (d, i) {\n    if (d >= 0) {\n      return d;\n    } else {\n      util.assert(d === -1, function () {\n        return \"Negative size values should be exactly -1 but got \" + \"\".concat(d, \" for the slice() size at index \").concat(i, \".\");\n      });\n      return x.shape[i] - begin_[i];\n    }\n  });\n  return [begin_, size_];\n} // Convert the slicing specification from a sparse representation to a dense\n// representation. This means that all ellipses and newaxis are expanded out.\n\nexport function sliceInfo(xShape, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask) {\n  var stridesNonNull;\n\n  if (strides == null) {\n    stridesNonNull = new Array(begin.length);\n    stridesNonNull.fill(1);\n  } else {\n    stridesNonNull = strides;\n  } // Only one non-zero bit is allowed in ellipsisMask, which means ellipsisMask\n  // is a power of 2. Use bit compares to ensure ellipsisMask is 0 or a power\n  // of 2. When i is a power of 2, i & (i - 1) is always 0.\n  // Also ref:\n  // https://stackoverflow.com/questions/600293/how-to-check-if-a-number-is-a-power-of-2\n\n\n  if (ellipsisMask != null && (ellipsisMask & ellipsisMask - 1) !== 0) {\n    throw new Error('Multiple ellipses in slice is not allowed.');\n  } // Step 1: Account for ellipsis and new axis.\n  // Check for ellipsis and count how many non-newaxis there are after.\n\n\n  var ellipsisSeen = false;\n  var sparseSpec = {\n    dims: stridesNonNull.length,\n    numAddAxisAfterEllipsis: 0,\n    begin: begin.slice(),\n    end: end.slice(),\n    strides: stridesNonNull.slice(),\n    beginMask: beginMask,\n    endMask: endMask,\n    ellipsisMask: ellipsisMask,\n    newAxisMask: newAxisMask,\n    shrinkAxisMask: shrinkAxisMask\n  };\n\n  for (var i = 0; i < sparseSpec.dims; i++) {\n    if (ellipsisSeen && (1 << i & newAxisMask) !== 0) {\n      sparseSpec.numAddAxisAfterEllipsis++;\n    }\n\n    if (1 << i & ellipsisMask) {\n      ellipsisSeen = true;\n    }\n  } // If no ellipsis insert one at the end.\n\n\n  if (!ellipsisSeen) {\n    sparseSpec.ellipsisMask |= 1 << sparseSpec.dims;\n    sparseSpec.dims++; // this effects loop iteration below\n  } // Step 2: Make a sparse spec into a full index spec.\n  //\n  // The sparse spec deos not correspond to the number of dimensions.\n  // Make a dense spec that cooresponds to the number of dimensions.\n  //\n  // For example suppose foo[...,3:] on foo.shape = [2, 2, 3] then we need to\n  // produce the missing beginMask for the first two dimensions i.e. from\n  // beginMaskSpec = 0, endMaskSpec = 2, we achieve beginMask = 6 (110),\n  // endMask = 7 (111).\n\n\n  var denseSpec = {\n    dims: xShape.length,\n    beginMask: 0,\n    endMask: 0,\n    beginValid: false,\n    endValid: false\n  };\n  buildDenseSpec(sparseSpec, denseSpec); // Step 3: Make implicit ranges (non-zero beginMasks and endMasks) explicit\n  // and bounds check.\n\n  var isIdentity = true;\n  var sliceDim0 = true;\n  var isSimpleSlice = true;\n  var processingShape = [];\n  var finalShape = [];\n\n  for (var _i3 = 0; _i3 < xShape.length; ++_i3) {\n    if (denseSpec.strides[_i3] === 0) {\n      throw Error(\"strides[\".concat(_i3, \"] must be non-zero\"));\n    }\n\n    var shrinkI = !!(denseSpec.shrinkAxisMask & 1 << _i3);\n    var dimI = xShape[_i3];\n\n    if (dimI === -1) {\n      processingShape.push(shrinkI ? 1 : -1);\n      continue;\n    }\n\n    var masks = [denseSpec.beginMask & 1 << _i3, denseSpec.endMask & 1 << _i3];\n    var validRange = [denseSpec.strides[_i3] > 0 ? 0 : -1, denseSpec.strides[_i3] > 0 ? dimI : dimI - 1];\n\n    if (shrinkI && denseSpec.strides[_i3] <= 0) {\n      throw Error('only stride 1 allowed on non-range indexing.');\n    }\n\n    isSimpleSlice = isSimpleSlice && denseSpec.strides[_i3] === 1;\n    var beginAndEndMasked = !!(denseSpec.beginMask & 1 << _i3 && denseSpec.endMask & 1 << _i3);\n\n    if (denseSpec.beginValid && denseSpec.endValid) {\n      if (shrinkI) {\n        // If we are shrinking, the end index is now possibly incorrect. In\n        // particular foo[-1] produces sparseBegin = -1, sparseEnd = 0.\n        // and canonical puts these to n-1 and 0, which implies a degenerate\n        // interval. Fortunately, it is now safe to re-create end as begin + 1.\n        var xFwd = denseSpec.begin[_i3] < 0 ? dimI + denseSpec.begin[_i3] : denseSpec.begin[_i3];\n        denseSpec.begin[_i3] = xFwd;\n        denseSpec.end[_i3] = denseSpec.begin[_i3] + 1;\n\n        if (xFwd < 0 || xFwd >= dimI) {\n          throw Error(\"slice index \".concat(denseSpec.begin[_i3], \" of dimension \").concat(_i3, \" out of bounds.\"));\n        }\n      } else {\n        denseSpec.begin[_i3] = canonical(denseSpec.begin[_i3], 0, denseSpec.strides[_i3], dimI, masks, validRange);\n        denseSpec.end[_i3] = canonical(denseSpec.end[_i3], 1, denseSpec.strides[_i3], dimI, masks, validRange);\n      } // Update optimization values\n\n\n      var takeAllInDimension = denseSpec.strides[_i3] === 1 && denseSpec.begin[_i3] === 0 && denseSpec.end[_i3] === dimI;\n      isIdentity = isIdentity && takeAllInDimension;\n      sliceDim0 = sliceDim0 && (_i3 === 0 && denseSpec.strides[_i3] === 1 || takeAllInDimension);\n    } else {\n      isIdentity = isIdentity && denseSpec.strides[_i3] === 1 && beginAndEndMasked;\n      sliceDim0 = sliceDim0 && (_i3 === 0 && denseSpec.strides[_i3] === 1 || beginAndEndMasked);\n    } // Compute the processing shape (the intermediate Eigen will produce)\n\n\n    var intervalLength = void 0;\n    var knownInterval = false;\n\n    if (denseSpec.beginValid && denseSpec.endValid) {\n      intervalLength = denseSpec.end[_i3] - denseSpec.begin[_i3];\n      knownInterval = true;\n    } else if (shrinkI) {\n      // The dimension is still known as 1 for the processingShape, but will be\n      // discarded for the final shape.\n      intervalLength = 1;\n      knownInterval = true;\n    } else if (beginAndEndMasked) {\n      // Even if we don't have values for begin or end, we do know that this\n      // dimension covers the whole interval. If we have shape information for\n      // this dimension, that tells us the interval length.\n      if (dimI >= 0) {\n        if (denseSpec.strides[_i3] < 0) {\n          intervalLength = -dimI;\n        } else {\n          intervalLength = dimI;\n        }\n\n        knownInterval = true;\n      }\n    }\n\n    if (knownInterval) {\n      var sizeI = void 0; // Hold zero if the interval is degenerate, otherwise account for\n      // remainder\n\n      if (intervalLength === 0 || intervalLength < 0 !== denseSpec.strides[_i3] < 0) {\n        sizeI = 0;\n      } else {\n        sizeI = Math.trunc(intervalLength / denseSpec.strides[_i3]) + (intervalLength % denseSpec.strides[_i3] !== 0 ? 1 : 0);\n      }\n\n      processingShape.push(sizeI);\n    } else {\n      processingShape.push(-1);\n    }\n  } // Step 4: Compute the final shape\n  //\n  // newAxis will increase dimension by 1 (with a one-size dimension)\n  // slices like foo[3, ...] will reduce dimension by 1.\n  // This cannot be done earlier, because it depends on Step 3.\n\n\n  for (var denseDim = 0; denseDim < denseSpec.finalShapeGatherIndices.length; ++denseDim) {\n    var gatherIndex = denseSpec.finalShapeGatherIndices[denseDim];\n\n    if (gatherIndex >= 0) {\n      finalShape.push(processingShape[gatherIndex]);\n    } else if (gatherIndex === NEW_AXIS) {\n      finalShape.push(1);\n    }\n  }\n\n  var finalShapeSparse = finalShape.filter(function (dim, i) {\n    return denseSpec.finalShapeGatherIndices[i] !== NEW_AXIS;\n  });\n  return {\n    finalShapeSparse: finalShapeSparse,\n    finalShape: finalShape,\n    isIdentity: isIdentity,\n    sliceDim0: sliceDim0,\n    isSimpleSlice: isSimpleSlice,\n    begin: denseSpec.begin,\n    end: denseSpec.end,\n    strides: denseSpec.strides\n  };\n}\n\nfunction buildDenseSpec(sparse, dense) {\n  dense.beginMask = 0;\n  dense.endMask = 0;\n  dense.shrinkAxisMask = 0;\n  var fullIndex = 0;\n  dense.beginValid = sparse.begin != null;\n  dense.endValid = sparse.end != null;\n  dense.begin = new Array(dense.dims);\n  dense.end = new Array(dense.dims);\n  dense.strides = new Array(dense.dims);\n  dense.finalShapeGatherIndices = [];\n  dense.finalShapeGatherIndicesSparse = [];\n  dense.inputShapeGatherIndicesSparse = new Array(dense.dims);\n\n  for (var i = 0; i < sparse.dims; i++) {\n    if (1 << i & sparse.ellipsisMask) {\n      // Only the bit that has ellipsis will fall in this condition.\n      // Expand the ellipsis into the appropriate indices\n      // Note: this only works because we guaranteed one ellipsis.\n      var nextIndex = Math.min(dense.dims - (sparse.dims - i) + 1 + sparse.numAddAxisAfterEllipsis, dense.dims);\n\n      for (; fullIndex < nextIndex; fullIndex++) {\n        // newAxis aren't real axis so you have to skip.\n        dense.begin[fullIndex] = 0;\n        dense.end[fullIndex] = 0;\n        dense.strides[fullIndex] = 1;\n        dense.beginMask |= 1 << fullIndex;\n        dense.endMask |= 1 << fullIndex;\n        dense.finalShapeGatherIndices.push(fullIndex);\n        dense.finalShapeGatherIndicesSparse.push(-1);\n        dense.inputShapeGatherIndicesSparse[fullIndex] = i;\n      }\n    } else if (1 << i & sparse.newAxisMask) {\n      // Only the bit that has newAxis will fall in this condition.\n      dense.finalShapeGatherIndices.push(NEW_AXIS);\n      dense.finalShapeGatherIndicesSparse.push(-1);\n    } else {\n      if (fullIndex === dense.begin.length) {\n        throw Error(\"Index out of range using input dim \".concat(fullIndex, \"; input \") + \"has only \".concat(dense.dims, \" dims, \").concat(dense.begin.length, \".\"));\n      } // Gather slicing spec into appropriate index.\n\n\n      if (sparse.begin != null) {\n        dense.begin[fullIndex] = sparse.begin[i];\n      }\n\n      if (sparse.end != null) {\n        dense.end[fullIndex] = sparse.end[i];\n      }\n\n      dense.strides[fullIndex] = sparse.strides[i];\n\n      if (sparse.beginMask & 1 << i) {\n        dense.beginMask |= 1 << fullIndex;\n      }\n\n      if (sparse.endMask & 1 << i) {\n        dense.endMask |= 1 << fullIndex;\n      } // If shrink, record where to get the dimensionality from (i.e. newAxis)\n      // creates a fake 1 size dimension. Also remember shrink axis (now in\n      // dense form) so we can ignore dense.end below.\n\n\n      if (sparse.shrinkAxisMask & 1 << i) {\n        dense.finalShapeGatherIndices.push(SHRINK_AXIS);\n        dense.finalShapeGatherIndicesSparse.push(-1);\n        dense.shrinkAxisMask |= 1 << fullIndex;\n      } else {\n        dense.finalShapeGatherIndices.push(fullIndex); // Remember that where in the sparse shape the dense dim comes from.\n\n        dense.finalShapeGatherIndicesSparse.push(i);\n      }\n\n      dense.inputShapeGatherIndicesSparse[fullIndex] = i;\n      fullIndex++;\n    }\n  }\n}\n\nfunction canonical(x, c, strideI, dimI, masks, validRange) {\n  if (masks[c]) {\n    return strideI > 0 ? validRange[c] : validRange[c + 1 & 1];\n  } else {\n    var xFwd = x < 0 ? dimI + x : x; // make negative indices positive\n\n    return xFwd < validRange[0] ? validRange[0] : xFwd > validRange[1] ? validRange[1] : xFwd;\n  }\n}","map":null,"metadata":{},"sourceType":"module"}