{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, GatherV2, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nimport { gatherV2Impl } from './GatherV2_impl';\nimport { reshape } from './Reshape';\nexport function gatherV2(args) {\n  var inputs = args.inputs,\n      backend = args.backend,\n      attrs = args.attrs;\n  var x = inputs.x,\n      indices = inputs.indices;\n  var axis = attrs.axis,\n      batchDims = attrs.batchDims;\n  assertNotComplex([x, indices], 'gatherV2'); // Throw error when any index is out of bound.\n\n  var parsedAxis = util.parseAxisParam(axis, x.shape)[0];\n  var indicesVals = backend.data.get(indices.dataId).values;\n  var axisDim = x.shape[parsedAxis];\n\n  var _loop = function _loop(i) {\n    var index = indicesVals[i];\n    util.assert(index <= axisDim - 1 && index >= 0, function () {\n      return \"GatherV2: the index value \".concat(index, \" is not in [0, \").concat(axisDim - 1, \"]\");\n    });\n  };\n\n  for (var i = 0; i < indicesVals.length; ++i) {\n    _loop(i);\n  }\n\n  var $batchDims = batchDims;\n\n  if (batchDims == null) {\n    $batchDims = 0;\n  }\n\n  var indicesSize = util.sizeFromShape(indices.shape);\n  var shapeInfo = backend_util.segment_util.collectGatherOpShapeInfo(x, indices, parsedAxis, $batchDims);\n  var flattenX = reshape({\n    inputs: {\n      x: x\n    },\n    backend: backend,\n    attrs: {\n      shape: [shapeInfo.batchSize, shapeInfo.outerSize, shapeInfo.dimSize, shapeInfo.sliceSize]\n    }\n  });\n  var flattenIndex = reshape({\n    inputs: {\n      x: indices\n    },\n    backend: backend,\n    attrs: {\n      shape: [shapeInfo.batchSize, indicesSize / shapeInfo.batchSize]\n    }\n  });\n  var flattenOutputShape = [shapeInfo.batchSize, shapeInfo.outerSize, indicesSize / shapeInfo.batchSize, shapeInfo.sliceSize];\n  var indicesBuf = backend.bufferSync(flattenIndex);\n  var xBuf = backend.bufferSync(flattenX);\n  var outBuf = gatherV2Impl(xBuf, indicesBuf, flattenOutputShape);\n  backend.disposeIntermediateTensorInfo(flattenX);\n  backend.disposeIntermediateTensorInfo(flattenIndex);\n  return backend.makeTensorInfo(shapeInfo.outputShape, outBuf.dtype, outBuf.values);\n}\nexport var gatherV2Config = {\n  kernelName: GatherV2,\n  backendName: 'cpu',\n  kernelFunc: gatherV2\n};","map":null,"metadata":{},"sourceType":"module"}