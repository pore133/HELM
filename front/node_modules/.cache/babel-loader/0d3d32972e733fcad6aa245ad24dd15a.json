{"ast":null,"code":"/**\r\n * DevExtreme (esm/core/utils/common.js)\r\n * Version: 23.1.6\r\n * Build date: Fri Oct 13 2023\r\n *\r\n * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport config from \"../config\";\nimport Guid from \"../guid\";\nimport { when, Deferred } from \"../utils/deferred\";\nimport { toComparable } from \"./data\";\nimport { each } from \"./iterator\";\nimport { isDefined, isFunction, isString, isObject, type } from \"./type\";\nexport var ensureDefined = function ensureDefined(value, defaultValue) {\n  return isDefined(value) ? value : defaultValue;\n};\nexport var executeAsync = function executeAsync(action, context) {\n  var deferred = new Deferred();\n  var normalizedContext = context || this;\n  var task = {\n    promise: deferred.promise(),\n    abort: function abort() {\n      clearTimeout(timerId);\n      deferred.rejectWith(normalizedContext);\n    }\n  };\n\n  var callback = function callback() {\n    var result = action.call(normalizedContext);\n\n    if (result && result.done && isFunction(result.done)) {\n      result.done(function () {\n        deferred.resolveWith(normalizedContext);\n      });\n    } else {\n      deferred.resolveWith(normalizedContext);\n    }\n  };\n\n  var timerId = (arguments[2] || setTimeout)(callback, \"number\" === typeof context ? context : 0);\n  return task;\n};\nvar delayedFuncs = [];\nvar delayedNames = [];\nvar delayedDeferreds = [];\nvar executingName;\n\nvar deferExecute = function deferExecute(name, func, deferred) {\n  if (executingName && executingName !== name) {\n    delayedFuncs.push(func);\n    delayedNames.push(name);\n    deferred = deferred || new Deferred();\n    delayedDeferreds.push(deferred);\n    return deferred;\n  } else {\n    var oldExecutingName = executingName;\n    var currentDelayedCount = delayedDeferreds.length;\n    executingName = name;\n    var result = func();\n\n    if (!result) {\n      if (delayedDeferreds.length > currentDelayedCount) {\n        result = when.apply(this, delayedDeferreds.slice(currentDelayedCount));\n      } else if (deferred) {\n        deferred.resolve();\n      }\n    }\n\n    executingName = oldExecutingName;\n\n    if (deferred && result && result.done) {\n      result.done(deferred.resolve).fail(deferred.reject);\n    }\n\n    if (!executingName && delayedFuncs.length) {\n      (\"render\" === delayedNames.shift() ? deferRender : deferUpdate)(delayedFuncs.shift(), delayedDeferreds.shift());\n    }\n\n    return result || when();\n  }\n};\n\nexport var deferRender = function deferRender(func, deferred) {\n  return deferExecute(\"render\", func, deferred);\n};\nexport var deferUpdate = function deferUpdate(func, deferred) {\n  return deferExecute(\"update\", func, deferred);\n};\nexport var deferRenderer = function deferRenderer(func) {\n  return function () {\n    var that = this;\n    return deferExecute(\"render\", function () {\n      return func.call(that);\n    });\n  };\n};\nexport var deferUpdater = function deferUpdater(func) {\n  return function () {\n    var that = this;\n    return deferExecute(\"update\", function () {\n      return func.call(that);\n    });\n  };\n};\nexport var findBestMatches = function findBestMatches(targetFilter, items, mapFn) {\n  var bestMatches = [];\n  var maxMatchCount = 0;\n  each(items, function (index, itemSrc) {\n    var matchCount = 0;\n    var item = mapFn ? mapFn(itemSrc) : itemSrc;\n    each(targetFilter, function (paramName, targetValue) {\n      var value = item[paramName];\n\n      if (void 0 === value) {\n        return;\n      }\n\n      if (match(value, targetValue)) {\n        matchCount++;\n        return;\n      }\n\n      matchCount = -1;\n      return false;\n    });\n\n    if (matchCount < maxMatchCount) {\n      return;\n    }\n\n    if (matchCount > maxMatchCount) {\n      bestMatches.length = 0;\n      maxMatchCount = matchCount;\n    }\n\n    bestMatches.push(itemSrc);\n  });\n  return bestMatches;\n};\n\nvar match = function match(value, targetValue) {\n  if (Array.isArray(value) && Array.isArray(targetValue)) {\n    var mismatch = false;\n    each(value, function (index, valueItem) {\n      if (valueItem !== targetValue[index]) {\n        mismatch = true;\n        return false;\n      }\n    });\n\n    if (mismatch) {\n      return false;\n    }\n\n    return true;\n  }\n\n  if (value === targetValue) {\n    return true;\n  }\n\n  return false;\n};\n\nexport var splitPair = function splitPair(raw) {\n  var _raw$x, _raw$y;\n\n  switch (type(raw)) {\n    case \"string\":\n      return raw.split(/\\s+/, 2);\n\n    case \"object\":\n      return [null !== (_raw$x = raw.x) && void 0 !== _raw$x ? _raw$x : raw.h, null !== (_raw$y = raw.y) && void 0 !== _raw$y ? _raw$y : raw.v];\n\n    case \"number\":\n      return [raw];\n\n    case \"array\":\n      return raw;\n\n    default:\n      return null;\n  }\n};\nexport var normalizeKey = function normalizeKey(id) {\n  var key = isString(id) ? id : id.toString();\n  var arr = key.match(/[^a-zA-Z0-9_]/g);\n  arr && each(arr, function (_, sign) {\n    key = key.replace(sign, \"__\" + sign.charCodeAt() + \"__\");\n  });\n  return key;\n};\nexport var denormalizeKey = function denormalizeKey(key) {\n  var arr = key.match(/__\\d+__/g);\n  arr && arr.forEach(function (char) {\n    var charCode = parseInt(char.replace(\"__\", \"\"));\n    key = key.replace(char, String.fromCharCode(charCode));\n  });\n  return key;\n};\nexport var pairToObject = function pairToObject(raw, preventRound) {\n  var pair = splitPair(raw);\n  var h = preventRound ? parseFloat(pair && pair[0]) : parseInt(pair && pair[0], 10);\n  var v = preventRound ? parseFloat(pair && pair[1]) : parseInt(pair && pair[1], 10);\n\n  if (!isFinite(h)) {\n    h = 0;\n  }\n\n  if (!isFinite(v)) {\n    v = h;\n  }\n\n  return {\n    h: h,\n    v: v\n  };\n};\nexport var getKeyHash = function getKeyHash(key) {\n  if (key instanceof Guid) {\n    return key.toString();\n  } else if (isObject(key) || Array.isArray(key)) {\n    try {\n      var keyHash = JSON.stringify(key);\n      return \"{}\" === keyHash ? key : keyHash;\n    } catch (e) {\n      return key;\n    }\n  }\n\n  return key;\n};\nexport var escapeRegExp = function escapeRegExp(string) {\n  return string.replace(/[[\\]{}\\-()*+?.\\\\^$|\\s]/g, \"\\\\$&\");\n};\nexport var applyServerDecimalSeparator = function applyServerDecimalSeparator(value) {\n  var separator = config().serverDecimalSeparator;\n\n  if (isDefined(value)) {\n    value = value.toString().replace(\".\", separator);\n  }\n\n  return value;\n};\nexport var noop = function noop() {};\nexport var asyncNoop = function asyncNoop() {\n  return new Deferred().resolve().promise();\n};\nexport var grep = function grep(elements, checkFunction, invert) {\n  var result = [];\n  var check;\n  var expectedCheck = !invert;\n\n  for (var i = 0; i < elements.length; i++) {\n    check = !!checkFunction(elements[i], i);\n\n    if (check === expectedCheck) {\n      result.push(elements[i]);\n    }\n  }\n\n  return result;\n};\n\nvar compareArrays = function compareArrays(array1, array2, depth, options) {\n  if (array1.length !== array2.length) {\n    return false;\n  }\n\n  return !array1.some(function (item, idx) {\n    return !compareByValue(item, array2[idx], depth + 1, _extends({}, options, {\n      strict: true\n    }));\n  });\n};\n\nvar compareObjects = function compareObjects(object1, object2, depth, options) {\n  var keys1 = Object.keys(object1);\n  var keys2 = Object.keys(object2);\n\n  if (keys1.length !== keys2.length) {\n    return false;\n  }\n\n  var keys2Set = new Set(keys2);\n  return !keys1.some(function (key) {\n    return !keys2Set.has(key) || !compareByValue(object1[key], object2[key], depth + 1, options);\n  });\n};\n\nvar DEFAULT_EQUAL_BY_VALUE_OPTS = {\n  maxDepth: 3,\n  strict: true\n};\n\nvar compareByValue = function compareByValue(value1, value2, depth, options) {\n  var strict = options.strict,\n      maxDepth = options.maxDepth;\n  var comparable1 = toComparable(value1, true);\n  var comparable2 = toComparable(value2, true);\n  var comparisonResult = strict ? comparable1 === comparable2 : comparable1 == comparable2;\n\n  switch (true) {\n    case comparisonResult:\n    case depth >= maxDepth:\n      return true;\n\n    case isObject(comparable1) && isObject(comparable2):\n      return compareObjects(comparable1, comparable2, depth, options);\n\n    case Array.isArray(comparable1) && Array.isArray(comparable2):\n      return compareArrays(comparable1, comparable2, depth, options);\n\n    default:\n      return false;\n  }\n};\n\nexport var equalByValue = function equalByValue(value1, value2) {\n  var options = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : DEFAULT_EQUAL_BY_VALUE_OPTS;\n\n  var compareOptions = _extends({}, DEFAULT_EQUAL_BY_VALUE_OPTS, options);\n\n  return compareByValue(value1, value2, 0, compareOptions);\n};","map":null,"metadata":{},"sourceType":"module"}