{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tf = require(\"@tensorflow/tfjs-core\");\n\nvar keypoints_1 = require(\"./keypoints\");\n\nfunction eitherPointDoesntMeetConfidence(a, b, minConfidence) {\n  return a < minConfidence || b < minConfidence;\n}\n\nfunction getAdjacentKeyPoints(keypoints, minConfidence) {\n  return keypoints_1.connectedPartIndices.reduce(function (result, _a) {\n    var leftJoint = _a[0],\n        rightJoint = _a[1];\n\n    if (eitherPointDoesntMeetConfidence(keypoints[leftJoint].score, keypoints[rightJoint].score, minConfidence)) {\n      return result;\n    }\n\n    result.push([keypoints[leftJoint], keypoints[rightJoint]]);\n    return result;\n  }, []);\n}\n\nexports.getAdjacentKeyPoints = getAdjacentKeyPoints;\nvar NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,\n    POSITIVE_INFINITY = Number.POSITIVE_INFINITY;\n\nfunction getBoundingBox(keypoints) {\n  return keypoints.reduce(function (_a, _b) {\n    var maxX = _a.maxX,\n        maxY = _a.maxY,\n        minX = _a.minX,\n        minY = _a.minY;\n    var _c = _b.position,\n        x = _c.x,\n        y = _c.y;\n    return {\n      maxX: Math.max(maxX, x),\n      maxY: Math.max(maxY, y),\n      minX: Math.min(minX, x),\n      minY: Math.min(minY, y)\n    };\n  }, {\n    maxX: NEGATIVE_INFINITY,\n    maxY: NEGATIVE_INFINITY,\n    minX: POSITIVE_INFINITY,\n    minY: POSITIVE_INFINITY\n  });\n}\n\nexports.getBoundingBox = getBoundingBox;\n\nfunction getBoundingBoxPoints(keypoints) {\n  var _a = getBoundingBox(keypoints),\n      minX = _a.minX,\n      minY = _a.minY,\n      maxX = _a.maxX,\n      maxY = _a.maxY;\n\n  return [{\n    x: minX,\n    y: minY\n  }, {\n    x: maxX,\n    y: minY\n  }, {\n    x: maxX,\n    y: maxY\n  }, {\n    x: minX,\n    y: maxY\n  }];\n}\n\nexports.getBoundingBoxPoints = getBoundingBoxPoints;\n\nfunction toTensorBuffers3D(tensors) {\n  return __awaiter(this, void 0, void 0, function () {\n    return __generator(this, function (_a) {\n      return [2\n      /*return*/\n      , Promise.all(tensors.map(function (tensor) {\n        return tensor.buffer();\n      }))];\n    });\n  });\n}\n\nexports.toTensorBuffers3D = toTensorBuffers3D;\n\nfunction scalePose(pose, scaleY, scaleX, offsetY, offsetX) {\n  if (offsetY === void 0) {\n    offsetY = 0;\n  }\n\n  if (offsetX === void 0) {\n    offsetX = 0;\n  }\n\n  return {\n    score: pose.score,\n    keypoints: pose.keypoints.map(function (_a) {\n      var score = _a.score,\n          part = _a.part,\n          position = _a.position;\n      return {\n        score: score,\n        part: part,\n        position: {\n          x: position.x * scaleX + offsetX,\n          y: position.y * scaleY + offsetY\n        }\n      };\n    })\n  };\n}\n\nexports.scalePose = scalePose;\n\nfunction scalePoses(poses, scaleY, scaleX, offsetY, offsetX) {\n  if (offsetY === void 0) {\n    offsetY = 0;\n  }\n\n  if (offsetX === void 0) {\n    offsetX = 0;\n  }\n\n  if (scaleX === 1 && scaleY === 1 && offsetY === 0 && offsetX === 0) {\n    return poses;\n  }\n\n  return poses.map(function (pose) {\n    return scalePose(pose, scaleY, scaleX, offsetY, offsetX);\n  });\n}\n\nexports.scalePoses = scalePoses;\n\nfunction flipPoseHorizontal(pose, imageWidth) {\n  return {\n    score: pose.score,\n    keypoints: pose.keypoints.map(function (_a) {\n      var score = _a.score,\n          part = _a.part,\n          position = _a.position;\n      return {\n        score: score,\n        part: part,\n        position: {\n          x: imageWidth - 1 - position.x,\n          y: position.y\n        }\n      };\n    })\n  };\n}\n\nexports.flipPoseHorizontal = flipPoseHorizontal;\n\nfunction flipPosesHorizontal(poses, imageWidth) {\n  if (imageWidth <= 0) {\n    return poses;\n  }\n\n  return poses.map(function (pose) {\n    return flipPoseHorizontal(pose, imageWidth);\n  });\n}\n\nexports.flipPosesHorizontal = flipPosesHorizontal;\n\nfunction toValidInputResolution(inputResolution, outputStride) {\n  if (isValidInputResolution(inputResolution, outputStride)) {\n    return inputResolution;\n  }\n\n  return Math.floor(inputResolution / outputStride) * outputStride + 1;\n}\n\nexports.toValidInputResolution = toValidInputResolution;\n\nfunction validateInputResolution(inputResolution) {\n  tf.util.assert(typeof inputResolution === 'number' || typeof inputResolution === 'object', function () {\n    return \"Invalid inputResolution \" + inputResolution + \". \" + \"Should be a number or an object with width and height\";\n  });\n\n  if (typeof inputResolution === 'object') {\n    tf.util.assert(typeof inputResolution.width === 'number', function () {\n      return \"inputResolution.width has a value of \" + inputResolution.width + \" which is invalid; it must be a number\";\n    });\n    tf.util.assert(typeof inputResolution.height === 'number', function () {\n      return \"inputResolution.height has a value of \" + inputResolution.height + \" which is invalid; it must be a number\";\n    });\n  }\n}\n\nexports.validateInputResolution = validateInputResolution;\n\nfunction getValidInputResolutionDimensions(inputResolution, outputStride) {\n  validateInputResolution(inputResolution);\n\n  if (typeof inputResolution === 'object') {\n    return [toValidInputResolution(inputResolution.height, outputStride), toValidInputResolution(inputResolution.width, outputStride)];\n  } else {\n    return [toValidInputResolution(inputResolution, outputStride), toValidInputResolution(inputResolution, outputStride)];\n  }\n}\n\nexports.getValidInputResolutionDimensions = getValidInputResolutionDimensions;\nvar VALID_OUTPUT_STRIDES = [8, 16, 32];\n\nfunction assertValidOutputStride(outputStride) {\n  tf.util.assert(typeof outputStride === 'number', function () {\n    return 'outputStride is not a number';\n  });\n  tf.util.assert(VALID_OUTPUT_STRIDES.indexOf(outputStride) >= 0, function () {\n    return \"outputStride of \" + outputStride + \" is invalid. \" + \"It must be either 8, 16, or 32\";\n  });\n}\n\nexports.assertValidOutputStride = assertValidOutputStride;\n\nfunction isValidInputResolution(resolution, outputStride) {\n  return (resolution - 1) % outputStride === 0;\n}\n\nfunction assertValidResolution(resolution, outputStride) {\n  tf.util.assert(typeof resolution[0] === 'number' && typeof resolution[1] === 'number', function () {\n    return \"both resolution values must be a number but had values \" + resolution;\n  });\n  tf.util.assert(isValidInputResolution(resolution[0], outputStride), function () {\n    return \"height of \" + resolution[0] + \" is invalid for output stride \" + (outputStride + \".\");\n  });\n  tf.util.assert(isValidInputResolution(resolution[1], outputStride), function () {\n    return \"width of \" + resolution[1] + \" is invalid for output stride \" + (outputStride + \".\");\n  });\n}\n\nexports.assertValidResolution = assertValidResolution;\n\nfunction getInputTensorDimensions(input) {\n  return input instanceof tf.Tensor ? [input.shape[0], input.shape[1]] : [input.height, input.width];\n}\n\nexports.getInputTensorDimensions = getInputTensorDimensions;\n\nfunction toInputTensor(input) {\n  return input instanceof tf.Tensor ? input : tf.browser.fromPixels(input);\n}\n\nexports.toInputTensor = toInputTensor;\n\nfunction toResizedInputTensor(input, resizeHeight, resizeWidth, flipHorizontal) {\n  return tf.tidy(function () {\n    var imageTensor = toInputTensor(input);\n\n    if (flipHorizontal) {\n      return tf.image.resizeBilinear(tf.reverse(imageTensor, 1), [resizeHeight, resizeWidth]);\n    } else {\n      return tf.image.resizeBilinear(imageTensor, [resizeHeight, resizeWidth]);\n    }\n  });\n}\n\nexports.toResizedInputTensor = toResizedInputTensor;\n\nfunction padAndResizeTo(input, _a) {\n  var targetH = _a[0],\n      targetW = _a[1];\n\n  var _b = getInputTensorDimensions(input),\n      height = _b[0],\n      width = _b[1];\n\n  var targetAspect = targetW / targetH;\n  var aspect = width / height;\n  var _c = [0, 0, 0, 0],\n      padT = _c[0],\n      padB = _c[1],\n      padL = _c[2],\n      padR = _c[3];\n\n  if (aspect < targetAspect) {\n    // pads the width\n    padT = 0;\n    padB = 0;\n    padL = Math.round(0.5 * (targetAspect * height - width));\n    padR = Math.round(0.5 * (targetAspect * height - width));\n  } else {\n    // pads the height\n    padT = Math.round(0.5 * (1.0 / targetAspect * width - height));\n    padB = Math.round(0.5 * (1.0 / targetAspect * width - height));\n    padL = 0;\n    padR = 0;\n  }\n\n  var resized = tf.tidy(function () {\n    var imageTensor = toInputTensor(input);\n    imageTensor = tf.pad3d(imageTensor, [[padT, padB], [padL, padR], [0, 0]]);\n    return tf.image.resizeBilinear(imageTensor, [targetH, targetW]);\n  });\n  return {\n    resized: resized,\n    padding: {\n      top: padT,\n      left: padL,\n      right: padR,\n      bottom: padB\n    }\n  };\n}\n\nexports.padAndResizeTo = padAndResizeTo;\n\nfunction scaleAndFlipPoses(poses, _a, _b, padding, flipHorizontal) {\n  var height = _a[0],\n      width = _a[1];\n  var inputResolutionHeight = _b[0],\n      inputResolutionWidth = _b[1];\n  var scaleY = (height + padding.top + padding.bottom) / inputResolutionHeight;\n  var scaleX = (width + padding.left + padding.right) / inputResolutionWidth;\n  var scaledPoses = scalePoses(poses, scaleY, scaleX, -padding.top, -padding.left);\n\n  if (flipHorizontal) {\n    return flipPosesHorizontal(scaledPoses, width);\n  } else {\n    return scaledPoses;\n  }\n}\n\nexports.scaleAndFlipPoses = scaleAndFlipPoses;","map":null,"metadata":{},"sourceType":"script"}