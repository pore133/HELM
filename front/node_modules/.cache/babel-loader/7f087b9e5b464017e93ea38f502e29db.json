{"ast":null,"code":"/**\n    * @license\n    * Copyright 2021 Google LLC. All Rights Reserved.\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    * http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    * =============================================================================\n    */\nimport * as tf from \"@tensorflow/tfjs-core\";\nimport { tidy, sub, div, util, Tensor, browser, image, pad3d, cast, expandDims, squeeze, sigmoid, scalar, mul, reshape, argMax, concat, tensor2d, add } from \"@tensorflow/tfjs-core\";\nimport { loadGraphModel } from \"@tensorflow/tfjs-converter\";\n\nvar _extendStatics = function extendStatics(e, t) {\n  return (_extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (e, t) {\n    e.__proto__ = t;\n  } || function (e, t) {\n    for (var n in t) {\n      t.hasOwnProperty(n) && (e[n] = t[n]);\n    }\n  })(e, t);\n};\n\nfunction __extends(e, t) {\n  function n() {\n    this.constructor = e;\n  }\n\n  _extendStatics(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n());\n}\n\nvar _assign = function __assign() {\n  return (_assign = Object.assign || function (e) {\n    for (var t, n = 1, r = arguments.length; n < r; n++) {\n      for (var o in t = arguments[n]) {\n        Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);\n      }\n    }\n\n    return e;\n  }).apply(this, arguments);\n};\n\nfunction __awaiter(e, t, n, r) {\n  return new (n || (n = Promise))(function (o, i) {\n    function s(e) {\n      try {\n        a(r.next(e));\n      } catch (e) {\n        i(e);\n      }\n    }\n\n    function u(e) {\n      try {\n        a(r.throw(e));\n      } catch (e) {\n        i(e);\n      }\n    }\n\n    function a(e) {\n      e.done ? o(e.value) : new n(function (t) {\n        t(e.value);\n      }).then(s, u);\n    }\n\n    a((r = r.apply(e, t || [])).next());\n  });\n}\n\nfunction __generator(e, t) {\n  var n,\n      r,\n      o,\n      i,\n      s = {\n    label: 0,\n    sent: function sent() {\n      if (1 & o[0]) throw o[1];\n      return o[1];\n    },\n    trys: [],\n    ops: []\n  };\n  return i = {\n    next: u(0),\n    throw: u(1),\n    return: u(2)\n  }, \"function\" == typeof Symbol && (i[Symbol.iterator] = function () {\n    return this;\n  }), i;\n\n  function u(i) {\n    return function (u) {\n      return function (i) {\n        if (n) throw new TypeError(\"Generator is already executing.\");\n\n        for (; s;) {\n          try {\n            if (n = 1, r && (o = 2 & i[0] ? r.return : i[0] ? r.throw || ((o = r.return) && o.call(r), 0) : r.next) && !(o = o.call(r, i[1])).done) return o;\n\n            switch (r = 0, o && (i = [2 & i[0], o.value]), i[0]) {\n              case 0:\n              case 1:\n                o = i;\n                break;\n\n              case 4:\n                return s.label++, {\n                  value: i[1],\n                  done: !1\n                };\n\n              case 5:\n                s.label++, r = i[1], i = [0];\n                continue;\n\n              case 7:\n                i = s.ops.pop(), s.trys.pop();\n                continue;\n\n              default:\n                if (!(o = (o = s.trys).length > 0 && o[o.length - 1]) && (6 === i[0] || 2 === i[0])) {\n                  s = 0;\n                  continue;\n                }\n\n                if (3 === i[0] && (!o || i[1] > o[0] && i[1] < o[3])) {\n                  s.label = i[1];\n                  break;\n                }\n\n                if (6 === i[0] && s.label < o[1]) {\n                  s.label = o[1], o = i;\n                  break;\n                }\n\n                if (o && s.label < o[2]) {\n                  s.label = o[2], s.ops.push(i);\n                  break;\n                }\n\n                o[2] && s.ops.pop(), s.trys.pop();\n                continue;\n            }\n\n            i = t.call(e, s);\n          } catch (e) {\n            i = [6, e], r = 0;\n          } finally {\n            n = o = 0;\n          }\n        }\n\n        if (5 & i[0]) throw i[1];\n        return {\n          value: i[0] ? i[1] : void 0,\n          done: !0\n        };\n      }([i, u]);\n    };\n  }\n}\n\nvar BaseModel = function () {\n  function e(e, t) {\n    this.model = e, this.outputStride = t;\n    var n = this.model.inputs[0].shape;\n    util.assert(-1 === n[1] && -1 === n[2], function () {\n      return \"Input shape [\" + n[1] + \", \" + n[2] + \"] must both be equal to or -1\";\n    });\n  }\n\n  return e.prototype.predict = function (e) {\n    var t = this;\n    return tidy(function () {\n      var n = t.preprocessInput(cast(e, \"float32\")),\n          r = expandDims(n, 0),\n          o = t.model.predict(r).map(function (e) {\n        return squeeze(e, [0]);\n      }),\n          i = t.nameOutputResults(o);\n      return {\n        heatmapScores: sigmoid(i.heatmap),\n        offsets: i.offsets,\n        displacementFwd: i.displacementFwd,\n        displacementBwd: i.displacementBwd\n      };\n    });\n  }, e.prototype.dispose = function () {\n    this.model.dispose();\n  }, e;\n}(),\n    MobileNet = function (e) {\n  function t() {\n    return null !== e && e.apply(this, arguments) || this;\n  }\n\n  return __extends(t, e), t.prototype.preprocessInput = function (e) {\n    return tidy(function () {\n      return sub(div(e, 127.5), 1);\n    });\n  }, t.prototype.nameOutputResults = function (e) {\n    return {\n      offsets: e[0],\n      heatmap: e[1],\n      displacementFwd: e[2],\n      displacementBwd: e[3]\n    };\n  }, t;\n}(BaseModel);\n\nfunction half(e) {\n  return Math.floor(e / 2);\n}\n\nvar MaxHeap = function () {\n  function e(e, t) {\n    this.priorityQueue = new Array(e), this.numberOfElements = -1, this.getElementValue = t;\n  }\n\n  return e.prototype.enqueue = function (e) {\n    this.priorityQueue[++this.numberOfElements] = e, this.swim(this.numberOfElements);\n  }, e.prototype.dequeue = function () {\n    var e = this.priorityQueue[0];\n    return this.exchange(0, this.numberOfElements--), this.sink(0), this.priorityQueue[this.numberOfElements + 1] = null, e;\n  }, e.prototype.empty = function () {\n    return -1 === this.numberOfElements;\n  }, e.prototype.size = function () {\n    return this.numberOfElements + 1;\n  }, e.prototype.all = function () {\n    return this.priorityQueue.slice(0, this.numberOfElements + 1);\n  }, e.prototype.max = function () {\n    return this.priorityQueue[0];\n  }, e.prototype.swim = function (e) {\n    for (; e > 0 && this.less(half(e), e);) {\n      this.exchange(e, half(e)), e = half(e);\n    }\n  }, e.prototype.sink = function (e) {\n    for (; 2 * e <= this.numberOfElements;) {\n      var t = 2 * e;\n      if (t < this.numberOfElements && this.less(t, t + 1) && t++, !this.less(e, t)) break;\n      this.exchange(e, t), e = t;\n    }\n  }, e.prototype.getValueAt = function (e) {\n    return this.getElementValue(this.priorityQueue[e]);\n  }, e.prototype.less = function (e, t) {\n    return this.getValueAt(e) < this.getValueAt(t);\n  }, e.prototype.exchange = function (e, t) {\n    var n = this.priorityQueue[e];\n    this.priorityQueue[e] = this.priorityQueue[t], this.priorityQueue[t] = n;\n  }, e;\n}();\n\nfunction scoreIsMaximumInLocalWindow(e, t, n, r, o, i) {\n  for (var s = i.shape, u = s[0], a = s[1], l = !0, p = Math.max(n - o, 0), c = Math.min(n + o + 1, u), d = p; d < c; ++d) {\n    for (var f = Math.max(r - o, 0), h = Math.min(r + o + 1, a), m = f; m < h; ++m) {\n      if (i.get(d, m, e) > t) {\n        l = !1;\n        break;\n      }\n    }\n\n    if (!l) break;\n  }\n\n  return l;\n}\n\nfunction buildPartWithScoreQueue(e, t, n) {\n  for (var r = n.shape, o = r[0], i = r[1], s = r[2], u = new MaxHeap(o * i * s, function (e) {\n    return e.score;\n  }), a = 0; a < o; ++a) {\n    for (var l = 0; l < i; ++l) {\n      for (var p = 0; p < s; ++p) {\n        var c = n.get(a, l, p);\n        c < e || scoreIsMaximumInLocalWindow(p, c, a, l, t, n) && u.enqueue({\n          score: c,\n          part: {\n            heatmapY: a,\n            heatmapX: l,\n            id: p\n          }\n        });\n      }\n    }\n  }\n\n  return u;\n}\n\nvar partNames = [\"nose\", \"leftEye\", \"rightEye\", \"leftEar\", \"rightEar\", \"leftShoulder\", \"rightShoulder\", \"leftElbow\", \"rightElbow\", \"leftWrist\", \"rightWrist\", \"leftHip\", \"rightHip\", \"leftKnee\", \"rightKnee\", \"leftAnkle\", \"rightAnkle\"],\n    NUM_KEYPOINTS = partNames.length,\n    partIds = partNames.reduce(function (e, t, n) {\n  return e[t] = n, e;\n}, {}),\n    connectedPartNames = [[\"leftHip\", \"leftShoulder\"], [\"leftElbow\", \"leftShoulder\"], [\"leftElbow\", \"leftWrist\"], [\"leftHip\", \"leftKnee\"], [\"leftKnee\", \"leftAnkle\"], [\"rightHip\", \"rightShoulder\"], [\"rightElbow\", \"rightShoulder\"], [\"rightElbow\", \"rightWrist\"], [\"rightHip\", \"rightKnee\"], [\"rightKnee\", \"rightAnkle\"], [\"leftShoulder\", \"rightShoulder\"], [\"leftHip\", \"rightHip\"]],\n    poseChain = [[\"nose\", \"leftEye\"], [\"leftEye\", \"leftEar\"], [\"nose\", \"rightEye\"], [\"rightEye\", \"rightEar\"], [\"nose\", \"leftShoulder\"], [\"leftShoulder\", \"leftElbow\"], [\"leftElbow\", \"leftWrist\"], [\"leftShoulder\", \"leftHip\"], [\"leftHip\", \"leftKnee\"], [\"leftKnee\", \"leftAnkle\"], [\"nose\", \"rightShoulder\"], [\"rightShoulder\", \"rightElbow\"], [\"rightElbow\", \"rightWrist\"], [\"rightShoulder\", \"rightHip\"], [\"rightHip\", \"rightKnee\"], [\"rightKnee\", \"rightAnkle\"]],\n    connectedPartIndices = connectedPartNames.map(function (e) {\n  var t = e[0],\n      n = e[1];\n  return [partIds[t], partIds[n]];\n}),\n    partChannels = [\"left_face\", \"right_face\", \"right_upper_leg_front\", \"right_lower_leg_back\", \"right_upper_leg_back\", \"left_lower_leg_front\", \"left_upper_leg_front\", \"left_upper_leg_back\", \"left_lower_leg_back\", \"right_feet\", \"right_lower_leg_front\", \"left_feet\", \"torso_front\", \"torso_back\", \"right_upper_arm_front\", \"right_upper_arm_back\", \"right_lower_arm_back\", \"left_lower_arm_front\", \"left_upper_arm_front\", \"left_upper_arm_back\", \"left_lower_arm_back\", \"right_hand\", \"right_lower_arm_front\", \"left_hand\"];\n\nfunction getOffsetPoint(e, t, n, r) {\n  return {\n    y: r.get(e, t, n),\n    x: r.get(e, t, n + NUM_KEYPOINTS)\n  };\n}\n\nfunction getImageCoords(e, t, n) {\n  var r = getOffsetPoint(e.heatmapY, e.heatmapX, e.id, n),\n      o = r.y,\n      i = r.x;\n  return {\n    x: e.heatmapX * t + i,\n    y: e.heatmapY * t + o\n  };\n}\n\nfunction clamp(e, t, n) {\n  return e < t ? t : e > n ? n : e;\n}\n\nfunction squaredDistance(e, t, n, r) {\n  var o = n - e,\n      i = r - t;\n  return o * o + i * i;\n}\n\nfunction addVectors(e, t) {\n  return {\n    x: e.x + t.x,\n    y: e.y + t.y\n  };\n}\n\nvar parentChildrenTuples = poseChain.map(function (e) {\n  var t = e[0],\n      n = e[1];\n  return [partIds[t], partIds[n]];\n}),\n    parentToChildEdges = parentChildrenTuples.map(function (e) {\n  return e[1];\n}),\n    childToParentEdges = parentChildrenTuples.map(function (e) {\n  return e[0];\n});\n\nfunction getDisplacement(e, t, n) {\n  var r = n.shape[2] / 2;\n  return {\n    y: n.get(t.y, t.x, e),\n    x: n.get(t.y, t.x, r + e)\n  };\n}\n\nfunction getStridedIndexNearPoint(e, t, n, r) {\n  return {\n    y: clamp(Math.round(e.y / t), 0, n - 1),\n    x: clamp(Math.round(e.x / t), 0, r - 1)\n  };\n}\n\nfunction traverseToTargetKeypoint(e, t, n, r, o, i, s, u) {\n  void 0 === u && (u = 2);\n\n  for (var a = r.shape, l = a[0], p = a[1], c = getDisplacement(e, getStridedIndexNearPoint(t.position, i, l, p), s), d = addVectors(t.position, c), f = 0; f < u; f++) {\n    var h = getStridedIndexNearPoint(d, i, l, p),\n        m = getOffsetPoint(h.y, h.x, n, o);\n    d = addVectors({\n      x: h.x * i,\n      y: h.y * i\n    }, {\n      x: m.x,\n      y: m.y\n    });\n  }\n\n  var g = getStridedIndexNearPoint(d, i, l, p),\n      _ = r.get(g.y, g.x, n);\n\n  return {\n    position: d,\n    part: partNames[n],\n    score: _\n  };\n}\n\nfunction decodePose(e, t, n, r, o, i) {\n  var s = t.shape[2],\n      u = parentToChildEdges.length,\n      a = new Array(s),\n      l = e.part,\n      p = e.score,\n      c = getImageCoords(l, r, n);\n  a[l.id] = {\n    score: p,\n    part: partNames[l.id],\n    position: c\n  };\n\n  for (var d = u - 1; d >= 0; --d) {\n    var f = parentToChildEdges[d],\n        h = childToParentEdges[d];\n    a[f] && !a[h] && (a[h] = traverseToTargetKeypoint(d, a[f], h, t, n, r, i));\n  }\n\n  for (d = 0; d < u; ++d) {\n    f = childToParentEdges[d], h = parentToChildEdges[d];\n    a[f] && !a[h] && (a[h] = traverseToTargetKeypoint(d, a[f], h, t, n, r, o));\n  }\n\n  return a;\n}\n\nfunction withinNmsRadiusOfCorrespondingPoint(e, t, n, r) {\n  var o = n.x,\n      i = n.y;\n  return e.some(function (e) {\n    var n = e.keypoints[r].position;\n    return squaredDistance(i, o, n.y, n.x) <= t;\n  });\n}\n\nfunction getInstanceScore(e, t, n) {\n  return n.reduce(function (n, r, o) {\n    var i = r.position,\n        s = r.score;\n    return withinNmsRadiusOfCorrespondingPoint(e, t, i, o) || (n += s), n;\n  }, 0) / n.length;\n}\n\nvar kLocalMaximumRadius = 1;\n\nfunction decodeMultiplePoses(e, t, n, r, o, i, s, u) {\n  void 0 === s && (s = .5), void 0 === u && (u = 20);\n\n  for (var a = [], l = buildPartWithScoreQueue(s, kLocalMaximumRadius, e), p = u * u; a.length < i && !l.empty();) {\n    var c = l.dequeue();\n\n    if (!withinNmsRadiusOfCorrespondingPoint(a, p, getImageCoords(c.part, o, t), c.part.id)) {\n      var d = decodePose(c, e, t, o, n, r),\n          f = getInstanceScore(a, p, d);\n      a.push({\n        keypoints: d,\n        score: f\n      });\n    }\n  }\n\n  return a;\n}\n\nfunction mod(e, t) {\n  return tidy(function () {\n    var n = div(e, scalar(t, \"int32\"));\n    return sub(e, mul(n, scalar(t, \"int32\")));\n  });\n}\n\nfunction argmax2d(e) {\n  var t = e.shape,\n      n = t[0],\n      r = t[1],\n      o = t[2];\n  return tidy(function () {\n    var t = reshape(e, [n * r, o]),\n        i = argMax(t, 0),\n        s = expandDims(div(i, scalar(r, \"int32\")), 1),\n        u = expandDims(mod(i, r), 1);\n    return concat([s, u], 1);\n  });\n}\n\nfunction getPointsConfidence(e, t) {\n  for (var n = t.shape[0], r = new Float32Array(n), o = 0; o < n; o++) {\n    var i = t.get(o, 0),\n        s = t.get(o, 1);\n    r[o] = e.get(i, s, o);\n  }\n\n  return r;\n}\n\nfunction getOffsetPoint$1(e, t, n, r) {\n  return {\n    y: r.get(e, t, n),\n    x: r.get(e, t, n + NUM_KEYPOINTS)\n  };\n}\n\nfunction getOffsetVectors(e, t) {\n  for (var n = [], r = 0; r < NUM_KEYPOINTS; r++) {\n    var o = getOffsetPoint$1(e.get(r, 0).valueOf(), e.get(r, 1).valueOf(), r, t),\n        i = o.x,\n        s = o.y;\n    n.push(s), n.push(i);\n  }\n\n  return tensor2d(n, [NUM_KEYPOINTS, 2]);\n}\n\nfunction getOffsetPoints(e, t, n) {\n  return tidy(function () {\n    var r = getOffsetVectors(e, n);\n    return add(cast(mul(e.toTensor(), scalar(t, \"int32\")), \"float32\"), r);\n  });\n}\n\nfunction decodeSinglePose(e, t, n) {\n  return __awaiter(this, void 0, void 0, function () {\n    var r, o, i, s, u, a, l, p, c, d;\n    return __generator(this, function (f) {\n      switch (f.label) {\n        case 0:\n          return r = 0, o = argmax2d(e), [4, Promise.all([e.buffer(), t.buffer(), o.buffer()])];\n\n        case 1:\n          return i = f.sent(), s = i[0], u = i[1], a = i[2], [4, (l = getOffsetPoints(a, n, u)).buffer()];\n\n        case 2:\n          return p = f.sent(), c = Array.from(getPointsConfidence(s, a)), d = c.map(function (e, t) {\n            return r += e, {\n              position: {\n                y: p.get(t, 0),\n                x: p.get(t, 1)\n              },\n              part: partNames[t],\n              score: e\n            };\n          }), o.dispose(), l.dispose(), [2, {\n            keypoints: d,\n            score: r / d.length\n          }];\n      }\n    });\n  });\n}\n\nvar MOBILENET_BASE_URL = \"https://storage.googleapis.com/tfjs-models/savedmodel/posenet/mobilenet/\",\n    RESNET50_BASE_URL = \"https://storage.googleapis.com/tfjs-models/savedmodel/posenet/resnet50/\";\n\nfunction resNet50Checkpoint(e, t) {\n  var n = \"model-stride\" + e + \".json\";\n  return 4 === t ? RESNET50_BASE_URL + \"float/\" + n : RESNET50_BASE_URL + \"quant\" + t + \"/\" + n;\n}\n\nfunction mobileNetCheckpoint(e, t, n) {\n  var r = {\n    1: \"100\",\n    .75: \"075\",\n    .5: \"050\"\n  },\n      o = \"model-stride\" + e + \".json\";\n  return 4 === n ? MOBILENET_BASE_URL + \"float/\" + r[t] + \"/\" + o : MOBILENET_BASE_URL + \"quant\" + n + \"/\" + r[t] + \"/\" + o;\n}\n\nvar imageNetMean = [-123.15, -115.9, -103.06],\n    ResNet = function (e) {\n  function t() {\n    return null !== e && e.apply(this, arguments) || this;\n  }\n\n  return __extends(t, e), t.prototype.preprocessInput = function (e) {\n    return add(e, imageNetMean);\n  }, t.prototype.nameOutputResults = function (e) {\n    var t = e[0],\n        n = e[1];\n    return {\n      offsets: e[2],\n      heatmap: e[3],\n      displacementFwd: t,\n      displacementBwd: n\n    };\n  }, t;\n}(BaseModel);\n\nfunction eitherPointDoesntMeetConfidence(e, t, n) {\n  return e < n || t < n;\n}\n\nfunction getAdjacentKeyPoints(e, t) {\n  return connectedPartIndices.reduce(function (n, r) {\n    var o = r[0],\n        i = r[1];\n    return eitherPointDoesntMeetConfidence(e[o].score, e[i].score, t) ? n : (n.push([e[o], e[i]]), n);\n  }, []);\n}\n\nvar NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,\n    POSITIVE_INFINITY = Number.POSITIVE_INFINITY;\n\nfunction getBoundingBox(e) {\n  return e.reduce(function (e, t) {\n    var n = e.maxX,\n        r = e.maxY,\n        o = e.minX,\n        i = e.minY,\n        s = t.position,\n        u = s.x,\n        a = s.y;\n    return {\n      maxX: Math.max(n, u),\n      maxY: Math.max(r, a),\n      minX: Math.min(o, u),\n      minY: Math.min(i, a)\n    };\n  }, {\n    maxX: NEGATIVE_INFINITY,\n    maxY: NEGATIVE_INFINITY,\n    minX: POSITIVE_INFINITY,\n    minY: POSITIVE_INFINITY\n  });\n}\n\nfunction getBoundingBoxPoints(e) {\n  var t = getBoundingBox(e),\n      n = t.minX,\n      r = t.minY,\n      o = t.maxX,\n      i = t.maxY;\n  return [{\n    x: n,\n    y: r\n  }, {\n    x: o,\n    y: r\n  }, {\n    x: o,\n    y: i\n  }, {\n    x: n,\n    y: i\n  }];\n}\n\nfunction toTensorBuffers3D(e) {\n  return __awaiter(this, void 0, void 0, function () {\n    return __generator(this, function (t) {\n      return [2, Promise.all(e.map(function (e) {\n        return e.buffer();\n      }))];\n    });\n  });\n}\n\nfunction scalePose(e, t, n, r, o) {\n  return void 0 === r && (r = 0), void 0 === o && (o = 0), {\n    score: e.score,\n    keypoints: e.keypoints.map(function (e) {\n      var i = e.score,\n          s = e.part,\n          u = e.position;\n      return {\n        score: i,\n        part: s,\n        position: {\n          x: u.x * n + o,\n          y: u.y * t + r\n        }\n      };\n    })\n  };\n}\n\nfunction scalePoses(e, t, n, r, o) {\n  return void 0 === r && (r = 0), void 0 === o && (o = 0), 1 === n && 1 === t && 0 === r && 0 === o ? e : e.map(function (e) {\n    return scalePose(e, t, n, r, o);\n  });\n}\n\nfunction flipPoseHorizontal(e, t) {\n  return {\n    score: e.score,\n    keypoints: e.keypoints.map(function (e) {\n      var n = e.score,\n          r = e.part,\n          o = e.position;\n      return {\n        score: n,\n        part: r,\n        position: {\n          x: t - 1 - o.x,\n          y: o.y\n        }\n      };\n    })\n  };\n}\n\nfunction flipPosesHorizontal(e, t) {\n  return t <= 0 ? e : e.map(function (e) {\n    return flipPoseHorizontal(e, t);\n  });\n}\n\nfunction toValidInputResolution(e, t) {\n  return isValidInputResolution(e, t) ? e : Math.floor(e / t) * t + 1;\n}\n\nfunction validateInputResolution(e) {\n  util.assert(\"number\" == typeof e || \"object\" == typeof e, function () {\n    return \"Invalid inputResolution \" + e + \". Should be a number or an object with width and height\";\n  }), \"object\" == typeof e && (util.assert(\"number\" == typeof e.width, function () {\n    return \"inputResolution.width has a value of \" + e.width + \" which is invalid; it must be a number\";\n  }), util.assert(\"number\" == typeof e.height, function () {\n    return \"inputResolution.height has a value of \" + e.height + \" which is invalid; it must be a number\";\n  }));\n}\n\nfunction getValidInputResolutionDimensions(e, t) {\n  return validateInputResolution(e), \"object\" == typeof e ? [toValidInputResolution(e.height, t), toValidInputResolution(e.width, t)] : [toValidInputResolution(e, t), toValidInputResolution(e, t)];\n}\n\nvar VALID_OUTPUT_STRIDES = [8, 16, 32];\n\nfunction assertValidOutputStride(e) {\n  util.assert(\"number\" == typeof e, function () {\n    return \"outputStride is not a number\";\n  }), util.assert(VALID_OUTPUT_STRIDES.indexOf(e) >= 0, function () {\n    return \"outputStride of \" + e + \" is invalid. It must be either 8, 16, or 32\";\n  });\n}\n\nfunction isValidInputResolution(e, t) {\n  return (e - 1) % t == 0;\n}\n\nfunction assertValidResolution(e, t) {\n  util.assert(\"number\" == typeof e[0] && \"number\" == typeof e[1], function () {\n    return \"both resolution values must be a number but had values \" + e;\n  }), util.assert(isValidInputResolution(e[0], t), function () {\n    return \"height of \" + e[0] + \" is invalid for output stride \" + t + \".\";\n  }), util.assert(isValidInputResolution(e[1], t), function () {\n    return \"width of \" + e[1] + \" is invalid for output stride \" + t + \".\";\n  });\n}\n\nfunction getInputTensorDimensions(e) {\n  return e instanceof Tensor ? [e.shape[0], e.shape[1]] : [e.height, e.width];\n}\n\nfunction toInputTensor(e) {\n  return e instanceof Tensor ? e : browser.fromPixels(e);\n}\n\nfunction padAndResizeTo(e, t) {\n  var n = t[0],\n      r = t[1],\n      o = getInputTensorDimensions(e),\n      i = o[0],\n      s = o[1],\n      u = r / n,\n      a = [0, 0, 0, 0],\n      l = a[0],\n      p = a[1],\n      c = a[2],\n      d = a[3];\n  return s / i < u ? (l = 0, p = 0, c = Math.round(.5 * (u * i - s)), d = Math.round(.5 * (u * i - s))) : (l = Math.round(.5 * (1 / u * s - i)), p = Math.round(.5 * (1 / u * s - i)), c = 0, d = 0), {\n    resized: tidy(function () {\n      var t = toInputTensor(e);\n      return t = pad3d(t, [[l, p], [c, d], [0, 0]]), image.resizeBilinear(t, [n, r]);\n    }),\n    padding: {\n      top: l,\n      left: c,\n      right: d,\n      bottom: p\n    }\n  };\n}\n\nfunction scaleAndFlipPoses(e, t, n, r, o) {\n  var i = t[0],\n      s = t[1],\n      u = n[0],\n      a = n[1],\n      l = scalePoses(e, (i + r.top + r.bottom) / u, (s + r.left + r.right) / a, -r.top, -r.left);\n  return o ? flipPosesHorizontal(l, s) : l;\n}\n\nvar MOBILENET_V1_CONFIG = {\n  architecture: \"MobileNetV1\",\n  outputStride: 16,\n  multiplier: .75,\n  inputResolution: 257\n},\n    VALID_ARCHITECTURE = [\"MobileNetV1\", \"ResNet50\"],\n    VALID_STRIDE = {\n  MobileNetV1: [8, 16, 32],\n  ResNet50: [32, 16]\n},\n    VALID_MULTIPLIER = {\n  MobileNetV1: [.5, .75, 1],\n  ResNet50: [1]\n},\n    VALID_QUANT_BYTES = [1, 2, 4];\n\nfunction validateModelConfig(e) {\n  if (null == (e = e || MOBILENET_V1_CONFIG).architecture && (e.architecture = \"MobileNetV1\"), VALID_ARCHITECTURE.indexOf(e.architecture) < 0) throw new Error(\"Invalid architecture \" + e.architecture + \". Should be one of \" + VALID_ARCHITECTURE);\n  if (null == e.inputResolution && (e.inputResolution = 257), validateInputResolution(e.inputResolution), null == e.outputStride && (e.outputStride = 16), VALID_STRIDE[e.architecture].indexOf(e.outputStride) < 0) throw new Error(\"Invalid outputStride \" + e.outputStride + \". Should be one of \" + VALID_STRIDE[e.architecture] + \" for architecture \" + e.architecture + \".\");\n  if (null == e.multiplier && (e.multiplier = 1), VALID_MULTIPLIER[e.architecture].indexOf(e.multiplier) < 0) throw new Error(\"Invalid multiplier \" + e.multiplier + \". Should be one of \" + VALID_MULTIPLIER[e.architecture] + \" for architecture \" + e.architecture + \".\");\n  if (null == e.quantBytes && (e.quantBytes = 4), VALID_QUANT_BYTES.indexOf(e.quantBytes) < 0) throw new Error(\"Invalid quantBytes \" + e.quantBytes + \". Should be one of \" + VALID_QUANT_BYTES + \" for architecture \" + e.architecture + \".\");\n  if (\"MobileNetV1\" === e.architecture && 32 === e.outputStride && 1 !== e.multiplier) throw new Error(\"When using an output stride of 32, you must select 1 as the multiplier.\");\n  return e;\n}\n\nvar SINGLE_PERSON_INFERENCE_CONFIG = {\n  flipHorizontal: !1\n},\n    MULTI_PERSON_INFERENCE_CONFIG = {\n  flipHorizontal: !1,\n  maxDetections: 5,\n  scoreThreshold: .5,\n  nmsRadius: 20\n};\n\nfunction validateMultiPersonInputConfig(e) {\n  var t = e.maxDetections,\n      n = e.scoreThreshold,\n      r = e.nmsRadius;\n  if (t <= 0) throw new Error(\"Invalid maxDetections \" + t + \". Should be > 0\");\n  if (n < 0 || n > 1) throw new Error(\"Invalid scoreThreshold \" + n + \". Should be in range [0.0, 1.0]\");\n  if (r <= 0) throw new Error(\"Invalid nmsRadius \" + r + \".\");\n}\n\nvar PoseNet = function () {\n  function e(e, t) {\n    assertValidOutputStride(e.outputStride), assertValidResolution(t, e.outputStride), this.baseModel = e, this.inputResolution = t;\n  }\n\n  return e.prototype.estimateMultiplePoses = function (e, t) {\n    return void 0 === t && (t = MULTI_PERSON_INFERENCE_CONFIG), __awaiter(this, void 0, void 0, function () {\n      var n, r, o, i, s, u, a, l, p, c, d, f, h, m, g, _, I, v, y, E, b;\n\n      return __generator(this, function (N) {\n        switch (N.label) {\n          case 0:\n            return n = _assign({}, MULTI_PERSON_INFERENCE_CONFIG, t), validateMultiPersonInputConfig(t), r = this.baseModel.outputStride, o = this.inputResolution, i = getInputTensorDimensions(e), s = i[0], u = i[1], a = padAndResizeTo(e, o), l = a.resized, p = a.padding, c = this.baseModel.predict(l), d = c.heatmapScores, f = c.offsets, h = c.displacementFwd, m = c.displacementBwd, [4, toTensorBuffers3D([d, f, h, m])];\n\n          case 1:\n            return g = N.sent(), _ = g[0], I = g[1], v = g[2], y = g[3], [4, decodeMultiplePoses(_, I, v, y, r, n.maxDetections, n.scoreThreshold, n.nmsRadius)];\n\n          case 2:\n            return E = N.sent(), b = scaleAndFlipPoses(E, [s, u], o, p, n.flipHorizontal), d.dispose(), f.dispose(), h.dispose(), m.dispose(), l.dispose(), [2, b];\n        }\n      });\n    });\n  }, e.prototype.estimateSinglePose = function (e, t) {\n    return void 0 === t && (t = SINGLE_PERSON_INFERENCE_CONFIG), __awaiter(this, void 0, void 0, function () {\n      var n, r, o, i, s, u, a, l, p, c, d, f, h, m, g, _;\n\n      return __generator(this, function (I) {\n        switch (I.label) {\n          case 0:\n            return n = _assign({}, SINGLE_PERSON_INFERENCE_CONFIG, t), r = this.baseModel.outputStride, o = this.inputResolution, i = getInputTensorDimensions(e), s = i[0], u = i[1], a = padAndResizeTo(e, o), l = a.resized, p = a.padding, c = this.baseModel.predict(l), d = c.heatmapScores, f = c.offsets, h = c.displacementFwd, m = c.displacementBwd, [4, decodeSinglePose(d, f, r)];\n\n          case 1:\n            return g = I.sent(), _ = scaleAndFlipPoses([g], [s, u], o, p, n.flipHorizontal), d.dispose(), f.dispose(), h.dispose(), m.dispose(), l.dispose(), [2, _[0]];\n        }\n      });\n    });\n  }, e.prototype.estimatePoses = function (e, t) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (n) {\n        switch (n.label) {\n          case 0:\n            return \"single-person\" !== t.decodingMethod ? [3, 2] : [4, this.estimateSinglePose(e, t)];\n\n          case 1:\n            return [2, [n.sent()]];\n\n          case 2:\n            return [2, this.estimateMultiplePoses(e, t)];\n        }\n      });\n    });\n  }, e.prototype.dispose = function () {\n    this.baseModel.dispose();\n  }, e;\n}();\n\nfunction loadMobileNet(e) {\n  return __awaiter(this, void 0, void 0, function () {\n    var t, n, r, o, i, s, u;\n    return __generator(this, function (a) {\n      switch (a.label) {\n        case 0:\n          if (t = e.outputStride, n = e.quantBytes, r = e.multiplier, null == tf) throw new Error(\"Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this\\n        model.\");\n          return o = mobileNetCheckpoint(t, r, n), [4, loadGraphModel(e.modelUrl || o)];\n\n        case 1:\n          return i = a.sent(), s = new MobileNet(i, t), u = getValidInputResolutionDimensions(e.inputResolution, s.outputStride), [2, new PoseNet(s, u)];\n      }\n    });\n  });\n}\n\nfunction loadResNet(e) {\n  return __awaiter(this, void 0, void 0, function () {\n    var t, n, r, o, i, s;\n    return __generator(this, function (u) {\n      switch (u.label) {\n        case 0:\n          if (t = e.outputStride, n = e.quantBytes, null == tf) throw new Error(\"Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this\\n        model.\");\n          return r = resNet50Checkpoint(t, n), [4, loadGraphModel(e.modelUrl || r)];\n\n        case 1:\n          return o = u.sent(), i = new ResNet(o, t), s = getValidInputResolutionDimensions(e.inputResolution, i.outputStride), [2, new PoseNet(i, s)];\n      }\n    });\n  });\n}\n\nfunction load(e) {\n  return void 0 === e && (e = MOBILENET_V1_CONFIG), __awaiter(this, void 0, void 0, function () {\n    return __generator(this, function (t) {\n      return \"ResNet50\" === (e = validateModelConfig(e)).architecture ? [2, loadResNet(e)] : \"MobileNetV1\" === e.architecture ? [2, loadMobileNet(e)] : [2, null];\n    });\n  });\n}\n\nvar version = \"2.2.2\";\nexport { decodeMultiplePoses, decodeSinglePose, MobileNet, partChannels, partIds, partNames, poseChain, load, PoseNet, getAdjacentKeyPoints, getBoundingBox, getBoundingBoxPoints, scaleAndFlipPoses, scalePose, version };","map":null,"metadata":{},"sourceType":"module"}